<!DOCTYPE html>


<html theme="dark" showBanner="true" hasBanner="false" > 
<link href="https://cdn.staticfile.org/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet">
<link href="https://cdn.staticfile.org/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet">
<link href="https://cdn.staticfile.org/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet">
<script src="/js/color.global.min.js" ></script>
<script src="/js/load-settings.js" ></script>
<head>
  <meta charset="utf-8">
  
  
  

  
  <title>SQL进阶使用技巧 | 陈sir爱狂扁</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="preload" href="/css/fonts/Roboto-Regular.ttf" as="font" type="font/ttf" crossorigin="anonymous">
  <link rel="preload" href="/css/fonts/Roboto-Bold.ttf" as="font" type="font/ttf" crossorigin="anonymous">

  <meta name="description" content="好文借鉴学习！！！https:&#x2F;&#x2F;github.com&#x2F;allentofight&#x2F;easy-cs&#x2F;blob&#x2F;main&#x2F;MySQL&#x2F;SQL%E8%BF%9B%E9%98%B6%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7.md?plain&#x3D;1由于工作需要，最近做了很多 BI 取数的工作，需要用到一些比较高级的 SQL 技巧，总结了一下工作中用到的一些比较骚的进阶，特此记录一">
<meta property="og:type" content="article">
<meta property="og:title" content="SQL进阶使用技巧">
<meta property="og:url" content="https://cheny-alf.github.io/2023/09/08/mysql-sql%E4%BC%98%E5%8C%96/index.html">
<meta property="og:site_name" content="陈sir爱狂扁">
<meta property="og:description" content="好文借鉴学习！！！https:&#x2F;&#x2F;github.com&#x2F;allentofight&#x2F;easy-cs&#x2F;blob&#x2F;main&#x2F;MySQL&#x2F;SQL%E8%BF%9B%E9%98%B6%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7.md?plain&#x3D;1由于工作需要，最近做了很多 BI 取数的工作，需要用到一些比较高级的 SQL 技巧，总结了一下工作中用到的一些比较骚的进阶，特此记录一">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://user-gold-cdn.xitu.io/2020/5/8/171f45f26bc2542d?w=818&h=283&f=png&s=30366">
<meta property="og:image" content="https://user-gold-cdn.xitu.io/2020/5/8/171f45f271f4a96f?w=318&h=280&f=png&s=16778">
<meta property="og:image" content="https://user-gold-cdn.xitu.io/2020/5/8/171f45f26ba5842c?w=419&h=216&f=png&s=17670">
<meta property="og:image" content="https://user-gold-cdn.xitu.io/2020/5/8/171f45f28a9ee43e?w=419&h=273&f=png&s=27006">
<meta property="og:image" content="https://user-gold-cdn.xitu.io/2020/5/8/171f45f1ebcb9b3c?w=366&h=175&f=png&s=17002">
<meta property="og:image" content="https://user-gold-cdn.xitu.io/2020/5/8/171f45f23af2ffa4?w=319&h=281&f=png&s=12891">
<meta property="og:image" content="https://user-gold-cdn.xitu.io/2020/5/8/171f45f332825699?w=1406&h=584&f=png&s=47266">
<meta property="og:image" content="https://user-gold-cdn.xitu.io/2020/5/8/171f45f341f95fba?w=974&h=539&f=png&s=49965">
<meta property="og:image" content="https://user-gold-cdn.xitu.io/2020/5/8/171f45f36457dfd3?w=818&h=283&f=png&s=36930">
<meta property="og:image" content="https://user-gold-cdn.xitu.io/2020/5/8/171f3cdebc558d86?w=430&h=430&f=jpeg&s=41396">
<meta property="article:published_time" content="2023-09-08T05:50:35.000Z">
<meta property="article:modified_time" content="2024-04-26T05:41:37.708Z">
<meta property="article:author" content="John Doe">
<meta property="article:tag" content="mysql">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://user-gold-cdn.xitu.io/2020/5/8/171f45f26bc2542d?w=818&h=283&f=png&s=30366">
  
  
    <link rel="icon" media="(prefers-color-scheme: light)" href="/images/favicon-light-32.png" sizes="32x32">
    <link rel="icon" media="(prefers-color-scheme: light)" href="/images/favicon-light-128.png" sizes="128x128">
    <link rel="icon" media="(prefers-color-scheme: light)" href="/images/favicon-light-180.png" sizes="180x180">
    <link rel="icon" media="(prefers-color-scheme: light)" href="/images/favicon-light-192.png" sizes="192x192">
    <link rel="icon" media="(prefers-color-scheme: dark)" href="/images/favicon-dark-32.png" sizes="32x32">
    <link rel="icon" media="(prefers-color-scheme: dark)" href="/images/favicon-dark-128.png" sizes="128x128">
    <link rel="icon" media="(prefers-color-scheme: dark)" href="/images/favicon-dark-180.png" sizes="180x180">
    <link rel="icon" media="(prefers-color-scheme: dark)" href="/images/favicon-dark-192.png" sizes="192x192">
  
  
  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 6.3.0"></head>

<body>
  
   
  <div id="main-grid" class="  ">
    <div id="nav" class=""  >
      <navbar id="navbar">
  <nav id="title-nav">
    <a href="/">
      <div id="vivia-logo">
        <div class="dot"></div>
        <div class="dot"></div>
        <div class="dot"></div>
        <div class="dot"></div>
      </div>
      <div>陈sir爱狂扁 </div>
    </a>
  </nav>
  <nav id="main-nav">
    
      <a class="main-nav-link" href="/">Home</a>
    
      <a class="main-nav-link" href="/archives">Archives</a>
    
      <a class="main-nav-link" href="/about">About</a>
    
  </nav>
  <nav id="sub-nav">
    <a id="theme-btn" class="nav-icon">
      <span class="light-mode-icon"><svg xmlns="http://www.w3.org/2000/svg" height="20" viewBox="0 -960 960 960" width="20"><path d="M438.5-829.913v-48q0-17.452 11.963-29.476 11.964-12.024 29.326-12.024 17.363 0 29.537 12.024t12.174 29.476v48q0 17.452-11.963 29.476-11.964 12.024-29.326 12.024-17.363 0-29.537-12.024T438.5-829.913Zm0 747.826v-48q0-17.452 11.963-29.476 11.964-12.024 29.326-12.024 17.363 0 29.537 12.024t12.174 29.476v48q0 17.452-11.963 29.476-11.964 12.024-29.326 12.024-17.363 0-29.537-12.024T438.5-82.087ZM877.913-438.5h-48q-17.452 0-29.476-11.963-12.024-11.964-12.024-29.326 0-17.363 12.024-29.537t29.476-12.174h48q17.452 0 29.476 11.963 12.024 11.964 12.024 29.326 0 17.363-12.024 29.537T877.913-438.5Zm-747.826 0h-48q-17.452 0-29.476-11.963-12.024-11.964-12.024-29.326 0-17.363 12.024-29.537T82.087-521.5h48q17.452 0 29.476 11.963 12.024 11.964 12.024 29.326 0 17.363-12.024 29.537T130.087-438.5Zm660.174-290.87-34.239 32q-12.913 12.674-29.565 12.174-16.653-.5-29.327-13.174-12.674-12.673-12.554-28.826.12-16.152 12.794-28.826l33-35q12.913-12.674 30.454-12.674t30.163 12.847q12.709 12.846 12.328 30.826-.38 17.98-13.054 30.653ZM262.63-203.978l-32 34q-12.913 12.674-30.454 12.674t-30.163-12.847q-12.709-12.846-12.328-30.826.38-17.98 13.054-30.653l33.239-31q12.913-12.674 29.565-12.174 16.653.5 29.327 13.174 12.674 12.673 12.554 28.826-.12 16.152-12.794 28.826Zm466.74 33.239-32-33.239q-12.674-12.913-12.174-29.565.5-16.653 13.174-29.327 12.673-12.674 28.826-13.054 16.152-.38 28.826 12.294l35 33q12.674 12.913 12.674 30.454t-12.847 30.163q-12.846 12.709-30.826 12.328-17.98-.38-30.653-13.054ZM203.978-697.37l-34-33q-12.674-12.913-13.174-29.945-.5-17.033 12.174-29.707t31.326-13.293q18.653-.62 31.326 13.054l32 34.239q11.674 12.913 11.174 29.565-.5 16.653-13.174 29.327-12.673 12.674-28.826 12.554-16.152-.12-28.826-12.794ZM480-240q-100 0-170-70t-70-170q0-100 70-170t170-70q100 0 170 70t70 170q0 100-70 170t-170 70Zm-.247-82q65.703 0 111.475-46.272Q637-414.544 637-480.247t-45.525-111.228Q545.95-637 480.247-637t-111.475 45.525Q323-545.95 323-480.247t45.525 111.975Q414.05-322 479.753-322ZM481-481Z"/></svg></span>
      <span class="dark-mode-icon"><svg xmlns="http://www.w3.org/2000/svg" height="20" viewBox="0 -960 960 960" width="20"><path d="M480.239-116.413q-152.63 0-258.228-105.478Q116.413-327.37 116.413-480q0-130.935 77.739-227.435t206.304-125.043q43.022-9.631 63.87 10.869t3.478 62.805q-8.891 22.043-14.315 44.463-5.424 22.42-5.424 46.689 0 91.694 64.326 155.879 64.325 64.186 156.218 64.186 24.369 0 46.978-4.946 22.609-4.945 44.413-14.076 42.826-17.369 62.967 1.142 20.142 18.511 10.511 61.054Q807.174-280 712.63-198.206q-94.543 81.793-232.391 81.793Zm0-95q79.783 0 143.337-40.217 63.554-40.218 95.793-108.283-15.608 4.044-31.097 5.326-15.49 1.283-31.859.805-123.706-4.066-210.777-90.539-87.071-86.473-91.614-212.092-.24-16.369.923-31.978 1.164-15.609 5.446-30.978-67.826 32.478-108.282 96.152Q211.652-559.543 211.652-480q0 111.929 78.329 190.258 78.329 78.329 190.258 78.329ZM466.13-465.891Z"/></svg></span>
    </a>
    
    <div id="nav-menu-btn" class="nav-icon">
      <svg xmlns="http://www.w3.org/2000/svg" height="20" viewBox="0 -960 960 960" width="20"><path d="M177.37-252.282q-17.453 0-29.477-11.964-12.024-11.963-12.024-29.326t12.024-29.537q12.024-12.174 29.477-12.174h605.26q17.453 0 29.477 11.964 12.024 11.963 12.024 29.326t-12.024 29.537q-12.024 12.174-29.477 12.174H177.37Zm0-186.218q-17.453 0-29.477-11.963-12.024-11.964-12.024-29.326 0-17.363 12.024-29.537T177.37-521.5h605.26q17.453 0 29.477 11.963 12.024 11.964 12.024 29.326 0 17.363-12.024 29.537T782.63-438.5H177.37Zm0-186.217q-17.453 0-29.477-11.964-12.024-11.963-12.024-29.326t12.024-29.537q12.024-12.174 29.477-12.174h605.26q17.453 0 29.477 11.964 12.024 11.963 12.024 29.326t-12.024 29.537q-12.024 12.174-29.477 12.174H177.37Z"/></svg>
    </div>
  </nav>
</navbar>
<div id="nav-dropdown" class="hidden">
  <div id="dropdown-link-list">
    
      <a class="nav-dropdown-link" href="/">Home</a>
    
      <a class="nav-dropdown-link" href="/archives">Archives</a>
    
      <a class="nav-dropdown-link" href="/about">About</a>
    
     
    </div>
</div>
<script>
  let dropdownBtn = document.getElementById("nav-menu-btn");
  let dropdownEle = document.getElementById("nav-dropdown");
  dropdownBtn.onclick = function() {
    dropdownEle.classList.toggle("hidden");
  }
</script>
    </div>
    <div id="sidebar-wrapper">
      <sidebar id="sidebar">
  
    <div class="widget-wrap">
  <div class="info-card">
    <div class="avatar">
      
        <image src=/./images/logo.jpg></image>
      
      <div class="img-dim"></div>
    </div>
    <div class="info">
      <div class="username">Cheny </div>
      <div class="dot"></div>
      <div class="subtitle">Someday i'll be just like You! </div>
      <div class="link-list">
        
          <a class="link-btn" target="_blank" rel="noopener" href="https://twitter.com" title="Twitter"><i class="fa-brands fa-twitter"></i></a>
        
          <a class="link-btn" target="_blank" rel="noopener" href="https://github.com/cheny-alf" title="GitHub"><i class="fa-brands fa-github"></i></a>
         
      </div>  
    </div>
  </div>
</div>

  
  <div class="sticky">
    
      


  <div class="widget-wrap">
    <div class="widget">
      <h3 class="widget-title">Categories</h3>
      <div class="category-box">
            <a class="category-link" href="/categories/%E6%8A%80%E6%9C%AF/">
                技术
                <div class="category-count">23</div>
            </a>
        </div>
    </div>
  </div>


    
      
  <div class="widget-wrap">
    <div class="widget">
      <h3 class="widget-title">Tags</h3>
      <ul class="widget-tag-list" itemprop="keywords"><li class="widget-tag-list-item"><a class="widget-tag-list-link" href="/tags/Golang/" rel="tag">Golang</a></li><li class="widget-tag-list-item"><a class="widget-tag-list-link" href="/tags/Kafka/" rel="tag">Kafka</a></li><li class="widget-tag-list-item"><a class="widget-tag-list-link" href="/tags/Redis/" rel="tag">Redis</a></li><li class="widget-tag-list-item"><a class="widget-tag-list-link" href="/tags/golang/" rel="tag">golang</a></li><li class="widget-tag-list-item"><a class="widget-tag-list-link" href="/tags/k8s/" rel="tag">k8s</a></li><li class="widget-tag-list-item"><a class="widget-tag-list-link" href="/tags/mysql/" rel="tag">mysql</a></li><li class="widget-tag-list-item"><a class="widget-tag-list-link" href="/tags/nsq/" rel="tag">nsq</a></li><li class="widget-tag-list-item"><a class="widget-tag-list-link" href="/tags/redis/" rel="tag">redis</a></li><li class="widget-tag-list-item"><a class="widget-tag-list-link" href="/tags/%E5%BB%B6%E8%BF%9F%E9%98%9F%E5%88%97/" rel="tag">延迟队列</a></li><li class="widget-tag-list-item"><a class="widget-tag-list-link" href="/tags/%E6%97%B6%E5%BA%8F%E6%95%B0%E6%8D%AE%E5%BA%93TSDB/" rel="tag">时序数据库TSDB</a></li><li class="widget-tag-list-item"><a class="widget-tag-list-link" href="/tags/%E7%9F%A5%E8%AF%86%E7%82%B9/" rel="tag">知识点</a></li><li class="widget-tag-list-item"><a class="widget-tag-list-link" href="/tags/%E9%99%90%E6%B5%81/" rel="tag">限流</a></li><li class="widget-tag-list-item"><a class="widget-tag-list-link" href="/tags/%E9%9D%A2%E8%AF%95/" rel="tag">面试</a></li></ul>
    </div>
  </div>


    
  </div>
</sidebar>
    </div>
    <div id="content-body">
       


<article id="post-mysql-sql优化" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  
    
   
  <div class="article-inner">
    <div class="article-main">
      <header class="article-header">
        
<div class="main-title-bar">
  <div class="main-title-dot"></div>
  
    
      <h1 class="p-name article-title" itemprop="headline name">
        SQL进阶使用技巧
      </h1>
    
  
</div>

        <div class='meta-info-bar'>
          <div class="meta-info">
  <time class="dt-published" datetime="2023-09-08T05:50:35.000Z" itemprop="datePublished">2023-09-08</time>
</div>
          <div class="need-seperator meta-info">
            <div class="meta-cate-flex">
  
  <a class="meta-cate-link" href="/categories/%E6%8A%80%E6%9C%AF/">技术</a>
   
</div>
  
          </div>
          <div class="wordcount need-seperator meta-info">
            7.1k words 
          </div>
        </div>
        
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/mysql/" rel="tag">mysql</a></li></ul>

      </header>
      <div class="e-content article-entry" itemprop="articleBody">
        
          <p>好文借鉴学习！！！<br><a target="_blank" rel="noopener" href="https://github.com/allentofight/easy-cs/blob/main/MySQL/SQL%E8%BF%9B%E9%98%B6%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7.md?plain=1">https://github.com/allentofight/easy-cs/blob/main/MySQL/SQL%E8%BF%9B%E9%98%B6%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7.md?plain=1</a><br>由于工作需要，最近做了很多 BI 取数的工作，需要用到一些比较高级的 SQL 技巧，总结了一下工作中用到的一些比较骚的进阶，特此记录一下，以方便自己查阅，主要目录如下：</p>
<ul>
<li>SQL 的书写规范</li>
<li>SQL 的一些进阶使用技巧</li>
<li>SQL 的优化方法</li>
</ul>
<h2 id="SQL-的书写规范"><a href="#SQL-的书写规范" class="headerlink" title="SQL 的书写规范"></a>SQL 的书写规范</h2><p>在介绍一些技巧之前，有必要强调一下规范，这一点我发现工作中经常被人忽略，其实遵循好的规范可读性会好很多，应该遵循哪些规范呢</p>
<p>1、 表名要有意义，且标准 SQL 中规定表名的第一个字符应该是字母。</p>
<p>2、注释，有单行注释和多行注释，如下</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 单行注释</span></span><br><span class="line"><span class="comment">-- 从SomeTable中查询col_1 </span></span><br><span class="line"><span class="keyword">SELECT</span> col_1</span><br><span class="line">  <span class="keyword">FROM</span> SomeTable;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">多行注释</span></span><br><span class="line"><span class="comment">从 SomeTable 中查询 col_1 </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">SELECT</span> col_1</span><br><span class="line">  <span class="keyword">FROM</span> SomeTable;</span><br></pre></td></tr></table></figure>
<p>多行注释很多人不知道，这种写法不用可以用来添加真正的溈，也可以用来注释代码，非常方便</p>
<p>3、缩进</p>
<p>就像写 Java，Python 等编程语言一样 ，SQL 也应该有缩进，良好地缩进对提升代码的可读性帮助很大，以下分别是好的缩进与坏的缩进示例</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 好的缩进</span></span><br><span class="line"><span class="keyword">SELECT</span> col_1, </span><br><span class="line">       col_2, </span><br><span class="line">       col_3,</span><br><span class="line">       <span class="built_in">COUNT</span>(<span class="operator">*</span>) </span><br><span class="line">  <span class="keyword">FROM</span> tbl_A</span><br><span class="line"> <span class="keyword">WHERE</span> col_1 <span class="operator">=</span> <span class="string">&#x27;a&#x27;</span></span><br><span class="line">   <span class="keyword">AND</span> col_2 <span class="operator">=</span> ( <span class="keyword">SELECT</span> <span class="built_in">MAX</span>(col_2)</span><br><span class="line">                   <span class="keyword">FROM</span> tbl_B</span><br><span class="line">                  <span class="keyword">WHERE</span> col_3 <span class="operator">=</span> <span class="number">100</span> )</span><br><span class="line"> <span class="keyword">GROUP</span> <span class="keyword">BY</span> col_1,</span><br><span class="line">          col_2,</span><br><span class="line">          col_3</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 坏的示例</span></span><br><span class="line"><span class="keyword">SELECT</span> col1_1, col_2, col_3, <span class="built_in">COUNT</span>(<span class="operator">*</span>)</span><br><span class="line"><span class="keyword">FROM</span>   tbl_A</span><br><span class="line"><span class="keyword">WHERE</span>  col1_1 <span class="operator">=</span> <span class="string">&#x27;a&#x27;</span></span><br><span class="line"><span class="keyword">AND</span>    col1_2 <span class="operator">=</span> (</span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">MAX</span>(col_2)</span><br><span class="line"><span class="keyword">FROM</span>   tbl_B</span><br><span class="line"><span class="keyword">WHERE</span>  col_3 <span class="operator">=</span> <span class="number">100</span></span><br><span class="line">) <span class="keyword">GROUP</span> <span class="keyword">BY</span> col_1, col_2, col_3</span><br></pre></td></tr></table></figure>

<p>4、空格</p>
<p>代码中应该适当留有一些空格，如果一点不留，代码都凑到一起， 逻辑单元不明确，阅读的人也会产生额外的压力，以下分别是是好的与坏的示例</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">-- 好的示例</span></span><br><span class="line"><span class="keyword">SELECT</span> col_1</span><br><span class="line">  <span class="keyword">FROM</span> tbl_A A, tbl_B B</span><br><span class="line"> <span class="keyword">WHERE</span> ( A.col_1 <span class="operator">&gt;=</span> <span class="number">100</span> <span class="keyword">OR</span> A.col_2 <span class="keyword">IN</span> ( <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span> ) )</span><br><span class="line">   <span class="keyword">AND</span> A.col_3 <span class="operator">=</span> B.col_3;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 坏的示例</span></span><br><span class="line"><span class="keyword">SELECT</span> col_1</span><br><span class="line">  <span class="keyword">FROM</span> tbl_A A,tbl_B B</span><br><span class="line"> <span class="keyword">WHERE</span> (A.col_1<span class="operator">&gt;=</span><span class="number">100</span> <span class="keyword">OR</span> A.col_2 <span class="keyword">IN</span> (<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>))</span><br><span class="line">   <span class="keyword">AND</span> A.col_3<span class="operator">=</span>B.col_3;</span><br></pre></td></tr></table></figure>


<p>4、大小写</p>
<p>关键字使用大小写，表名列名使用小写，如下</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> col_1, col_2, col_3,</span><br><span class="line">       <span class="built_in">COUNT</span>(<span class="operator">*</span>)</span><br><span class="line">  <span class="keyword">FROM</span> tbl_A</span><br><span class="line"> <span class="keyword">WHERE</span> col_1 <span class="operator">=</span> <span class="string">&#x27;a&#x27;</span></span><br><span class="line">   <span class="keyword">AND</span> col_2 <span class="operator">=</span> ( <span class="keyword">SELECT</span> <span class="built_in">MAX</span>(col_2)</span><br><span class="line">                   <span class="keyword">FROM</span> tbl_B</span><br><span class="line">                  <span class="keyword">WHERE</span> col_3 <span class="operator">=</span> <span class="number">100</span> )</span><br><span class="line"> <span class="keyword">GROUP</span> <span class="keyword">BY</span> col_1, col_2, col_3</span><br></pre></td></tr></table></figure>

<p>花了这么多时间强调规范，有必要吗，有！好的规范让代码的可读性更好，更有利于团队合作，之后的 SQL 示例都会遵循这些规范。</p>
<h2 id="SQL-的一些进阶使用技巧"><a href="#SQL-的一些进阶使用技巧" class="headerlink" title="SQL 的一些进阶使用技巧"></a>SQL 的一些进阶使用技巧</h2><p><strong>一、巧用 CASE WHEN 进行统计</strong></p>
<p>来看看如何巧用 CASE WHEN 进行定制化统计,假设我们有如下的需求，希望根据左边各个市的人口统计每个省的人口</p>
<p><img src="https://user-gold-cdn.xitu.io/2020/5/8/171f45f26bc2542d?w=818&h=283&f=png&s=30366"></p>
<p>使用 CASE WHEN 如下</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">CASE</span> pref_name</span><br><span class="line">               <span class="keyword">WHEN</span> <span class="string">&#x27;长沙&#x27;</span> <span class="keyword">THEN</span> <span class="string">&#x27;湖南&#x27;</span> </span><br><span class="line">               <span class="keyword">WHEN</span> <span class="string">&#x27;衡阳&#x27;</span> <span class="keyword">THEN</span> <span class="string">&#x27;湖南&#x27;</span></span><br><span class="line">               <span class="keyword">WHEN</span> <span class="string">&#x27;海口&#x27;</span> <span class="keyword">THEN</span> <span class="string">&#x27;海南&#x27;</span> </span><br><span class="line">               <span class="keyword">WHEN</span> <span class="string">&#x27;三亚&#x27;</span> <span class="keyword">THEN</span> <span class="string">&#x27;海南&#x27;</span></span><br><span class="line">       <span class="keyword">ELSE</span> <span class="string">&#x27;其他&#x27;</span> <span class="keyword">END</span> <span class="keyword">AS</span> district,</span><br><span class="line">       <span class="built_in">SUM</span>(population) </span><br><span class="line"><span class="keyword">FROM</span> PopTbl</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> district;</span><br></pre></td></tr></table></figure>

<p><strong>二、巧用 CASE WHEN 进行更新</strong></p>
<p>现在某公司员人工资信息表如下:</p>
<p><img src="https://user-gold-cdn.xitu.io/2020/5/8/171f45f271f4a96f?w=318&h=280&f=png&s=16778"></p>
<p>现在公司出台了一个奇葩的规定</p>
<ol>
<li>对当前工资为 1 万以上的员工，降薪 10%。</li>
<li>对当前工资低于 1 万的员工，加薪 20%。</li>
</ol>
<p>一些人不假思索可能写出了以下的 SQL:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--条件1</span></span><br><span class="line"><span class="keyword">UPDATE</span> Salaries</span><br><span class="line"><span class="keyword">SET</span> salary <span class="operator">=</span> salary <span class="operator">*</span> <span class="number">0.9</span> <span class="keyword">WHERE</span> salary <span class="operator">&gt;=</span> <span class="number">10000</span>;</span><br><span class="line"><span class="comment">--条件2</span></span><br><span class="line"><span class="keyword">UPDATE</span> Salaries</span><br><span class="line"><span class="keyword">SET</span> salary <span class="operator">=</span> salary <span class="operator">*</span> <span class="number">1.2</span></span><br><span class="line"><span class="keyword">WHERE</span> salary <span class="operator">&lt;</span> <span class="number">10000</span>;</span><br></pre></td></tr></table></figure>
<p>这么做其实是有问题的， 什么问题，对小明来说，他的工资是 10500，执行第一个 SQL 后，工资变为 10500 * 0.9 &#x3D; 9450, 紧接着又执行条件 2， 工资变为了 9450 * 1.2 &#x3D; 11340，反而涨薪了！</p>
<p>如果用 CASE WHEN 可以解决此类问题，如下：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> Salaries</span><br><span class="line"><span class="keyword">SET</span> salary <span class="operator">=</span> <span class="keyword">CASE</span> <span class="keyword">WHEN</span> salary <span class="operator">&gt;=</span> <span class="number">10000</span> <span class="keyword">THEN</span> salary <span class="operator">*</span> <span class="number">0.9</span></span><br><span class="line"><span class="keyword">WHEN</span> salary <span class="operator">&lt;</span> <span class="number">280000</span> <span class="keyword">THEN</span> salary <span class="operator">*</span> <span class="number">1.2</span></span><br><span class="line"><span class="keyword">ELSE</span> salary <span class="keyword">END</span>;</span><br></pre></td></tr></table></figure>

<p><strong>三、巧用 HAVING 子句</strong></p>
<p>一般 HAVING 是与 GROUP BY 结合使用的，但其实它是可以独立使用的，<br>假设有如下表，第一列 seq 叫连续编号，但其实有些编号是缺失的，怎么知道编号是否缺失呢，</p>
<p><img src="https://user-gold-cdn.xitu.io/2020/5/8/171f45f26ba5842c?w=419&h=216&f=png&s=17670"></p>
<p>用 HAVING 表示如下:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="string">&#x27;存在缺失的编号&#x27;</span> <span class="keyword">AS</span> gap</span><br><span class="line">  <span class="keyword">FROM</span> SeqTbl</span><br><span class="line"><span class="keyword">HAVING</span> <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="operator">&lt;&gt;</span> <span class="built_in">MAX</span>(seq);</span><br></pre></td></tr></table></figure>

<p><strong>四、自连接</strong></p>
<p>针对相同的表进行的连接被称为“自连接”(self join)，这个技巧常常被人们忽视，其实是有挺多妙用的</p>
<p>1、删除重复行</p>
<p><img src="https://user-gold-cdn.xitu.io/2020/5/8/171f45f28a9ee43e?w=419&h=273&f=png&s=27006"></p>
<p>上图中有三个橘子，需要把这些重复的行给删掉，用如下自连接可以解决：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> Products P1</span><br><span class="line"> <span class="keyword">WHERE</span> id <span class="operator">&lt;</span> ( <span class="keyword">SELECT</span> <span class="built_in">MAX</span>(P2.id) </span><br><span class="line">                   <span class="keyword">FROM</span> Products P2 </span><br><span class="line">                  <span class="keyword">WHERE</span> P1.name <span class="operator">=</span> P2.name </span><br><span class="line">                    <span class="keyword">AND</span> P1.price <span class="operator">=</span> P2.price ); </span><br></pre></td></tr></table></figure>

<p>2、排序</p>
<p>在 db 中，我们经常需要按分数，人数，销售额等进行排名，有 Oracle, DB2 中可以使用 RANK 函数进行排名，不过在 MySQL 中 RANK 函数未实现，这种情况我们可以使用自连接来实现,如对以下 Products 表按价格高低进行排名</p>
<p><img src="https://user-gold-cdn.xitu.io/2020/5/8/171f45f1ebcb9b3c?w=366&h=175&f=png&s=17002"></p>
<p>使用自连接可以这么写:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 排序从 1 开始。如果已出现相同位次，则跳过之后的位次 </span></span><br><span class="line"><span class="keyword">SELECT</span> P1.name,</span><br><span class="line">       P1.price,</span><br><span class="line">       (<span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(P2.price)</span><br><span class="line">          <span class="keyword">FROM</span> Products P2</span><br><span class="line">         <span class="keyword">WHERE</span> P2.price <span class="operator">&gt;</span> P1.price) <span class="operator">+</span> <span class="number">1</span> <span class="keyword">AS</span> rank_1</span><br><span class="line">  <span class="keyword">FROM</span> Products P1 </span><br><span class="line">  <span class="keyword">ORDER</span> <span class="keyword">BY</span> rank_1;</span><br></pre></td></tr></table></figure>

<p>结果如下:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">name price rank </span><br><span class="line"><span class="comment">----- ------ ------ </span></span><br><span class="line">橘子    <span class="number">100</span>     <span class="number">1</span> </span><br><span class="line">西瓜     <span class="number">80</span>     <span class="number">2</span> </span><br><span class="line">苹果     <span class="number">50</span>     <span class="number">3</span> </span><br><span class="line">葡萄     <span class="number">50</span>     <span class="number">3</span> </span><br><span class="line">香蕉     <span class="number">50</span>     <span class="number">3</span> </span><br><span class="line">柠檬     <span class="number">30</span>     <span class="number">6</span></span><br></pre></td></tr></table></figure>

<p><strong>五、巧用 COALESCE 函数</strong></p>
<p>此函数作用返回参数中的第一个非空表达式，假设有如下商品，我们重新格式化一样，如果 city 为 null，代表商品不在此城市发行，但我们在展示结果的时候不想展示 null，而想展示 ‘N&#x2F;A’, 可以这么做:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> </span><br><span class="line">    <span class="built_in">COALESCE</span>(city, <span class="string">&#x27;N/A&#x27;</span>)</span><br><span class="line">  <span class="keyword">FROM</span></span><br><span class="line">    customers;</span><br></pre></td></tr></table></figure>

<p><img src="https://user-gold-cdn.xitu.io/2020/5/8/171f45f23af2ffa4?w=319&h=281&f=png&s=12891"></p>
<h2 id="SQL-性能优化技巧"><a href="#SQL-性能优化技巧" class="headerlink" title="SQL 性能优化技巧"></a>SQL 性能优化技巧</h2><p><strong>一、参数是子查询时，使用 EXISTS 代替 IN</strong></p>
<p>如果 IN 的参数是（1，2，3）这样的值列表时，没啥问题，但如果参数是子查询时，就需要注意了。比如，现在有如下两个表：</p>
<p><img src="https://user-gold-cdn.xitu.io/2020/5/8/171f45f332825699?w=1406&h=584&f=png&s=47266"></p>
<p>现在我们要查出同时存在于两个表的员工，即小明和小东，则以下用 IN 和 EXISTS 返回的结果是一样，但是用 EXISTS 的 SQL 会更快:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">-- 慢</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> </span><br><span class="line">  <span class="keyword">FROM</span> Class_A</span><br><span class="line"><span class="keyword">WHERE</span> id <span class="keyword">IN</span> (<span class="keyword">SELECT</span> id </span><br><span class="line">               <span class="keyword">FROM</span>  CLASS_B);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 快</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line">  <span class="keyword">FROM</span> Class_A A </span><br><span class="line"> <span class="keyword">WHERE</span> <span class="keyword">EXISTS</span></span><br><span class="line">(<span class="keyword">SELECT</span> <span class="operator">*</span> </span><br><span class="line">   <span class="keyword">FROM</span> Class_B  B</span><br><span class="line">  <span class="keyword">WHERE</span> A.id <span class="operator">=</span> B.id);</span><br></pre></td></tr></table></figure>

<p>为啥使用 EXISTS 的 SQL 运行更快呢，有两个原因</p>
<ol>
<li>可以&#96;用到索引，如果连接列 (id) 上建立了索引，那么查询 Class_B 时不用查实际的表，只需查索引就可以了。</li>
<li>如果使用 EXISTS，那么只要查到一行数据满足条件就会终止查询， 不用像使用 IN 时一样扫描全表。在这一点上 NOT EXISTS 也一样</li>
</ol>
<p>另外如果 IN 后面如果跟着的是子查询，由于 SQL 会先执行 IN 后面的子查询，会将子查询的结果保存在一张临时的工作表里（内联视图），然后扫描<strong>整个视图</strong>，显然扫描整个视图这个工作很多时候是非常耗时的，而用 EXISTS 不会生成临时表。</p>
<p>当然了，如果 IN 的参数是子查询时，也可以用连接来代替，如下：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 使用连接代替 IN SELECT A.id, A.name</span></span><br><span class="line"><span class="keyword">FROM</span> Class_A A <span class="keyword">INNER</span> <span class="keyword">JOIN</span> Class_B B <span class="keyword">ON</span> A.id <span class="operator">=</span> B.id;</span><br></pre></td></tr></table></figure>
<p>用到了 「id」列上的索引，而且由于没有子查询，也不会生成临时表</p>
<p><strong>二、避免排序</strong></p>
<p>SQL 是声明式语言，即对用户来说，只关心它能做什么，不用关心它怎么做。这样可能会产生潜在的性能问题：排序，会产生排序的代表性运算有下面这些</p>
<ul>
<li>GROUP BY 子句</li>
<li>ORDER BY 子句</li>
<li>聚合函数(SUM、COUNT、AVG、MAX、MIN)</li>
<li>DISTINCT</li>
<li>集合运算符(UNION、INTERSECT、EXCEPT)</li>
<li>窗口函数(RANK、ROW_NUMBER 等)</li>
</ul>
<p>如果在内存中排序还好，但如果内存不够导致需要在硬盘上排序上的话，性能就会急剧下降，所以我们需要减少不必要的排序。怎样做可以减少排序呢。</p>
<p>1、 使用集合运算符的 ALL 可选项</p>
<p>SQL 中有 UNION，INTERSECT，EXCEPT 三个集合运算符，默认情况下，这些运算符会为了避免重复数据而进行排序，对比一下使用 UNION 运算符加和不加 ALL 的情况:</p>
<p><img src="https://user-gold-cdn.xitu.io/2020/5/8/171f45f341f95fba?w=974&h=539&f=png&s=49965"></p>
<p>注意：加 ALL 是优化性能非常有效的手段，不过前提是不在乎结果是否有重复数据。</p>
<p>2、使用 EXISTS 代表 DISTINCT</p>
<p>为了排除重复数据， DISTINCT 也会对结果进行排序，如果需要对两张表的连接结果进行去重，可以考虑用 EXISTS 代替 DISTINCT，这样可以避免排序。</p>
<p><img src="https://user-gold-cdn.xitu.io/2020/5/8/171f45f36457dfd3?w=818&h=283&f=png&s=36930"></p>
<p>如何找出有销售记录的商品，使用如下 DISTINCT 可以：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> I.item_no</span><br><span class="line"><span class="keyword">FROM</span> Items I <span class="keyword">INNER</span> <span class="keyword">JOIN</span> SalesHistory SH</span><br><span class="line"><span class="keyword">ON</span> I. item_no <span class="operator">=</span> SH. item_no;</span><br></pre></td></tr></table></figure>

<p>不过更好的方式是使用 EXISTS:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> item_no <span class="keyword">FROM</span> Items I</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">EXISTS</span> </span><br><span class="line">        (<span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line">           <span class="keyword">FROM</span> SalesHistory SH</span><br><span class="line">          <span class="keyword">WHERE</span> I.item_no <span class="operator">=</span> SH.item_no);</span><br></pre></td></tr></table></figure>

<p>既用到了索引，又避免了排序对性能的损耗。</p>
<p><strong>二、在极值函数中使用索引（MAX&#x2F;MIN）</strong></p>
<p>使用 MAX&#x2F; MIN 都会对进行排序，如果参数字段上没加索引会导致全表扫描，如果建有索引，则只需要扫描索引即可，对比如下</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 这样写需要扫描全表 </span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">MAX</span>(item)</span><br><span class="line">  <span class="keyword">FROM</span> Items;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 这样写能用到索引 </span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">MAX</span>(item_no)</span><br><span class="line">  <span class="keyword">FROM</span> Items;</span><br></pre></td></tr></table></figure>

<p>注意：极值函数参数推荐为索引列中并不是不需要排序，而是优化了排序前的查找速度（毕竟索引本身就是有序排列的）。</p>
<p><strong>三、能写在 WHERE 子句里的条件不要写在 HAVING 子句里</strong></p>
<p>下列 SQL 语句返回的结果是一样的:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 聚合后使用 HAVING 子句过滤</span></span><br><span class="line"><span class="keyword">SELECT</span> sale_date, <span class="built_in">SUM</span>(quantity)</span><br><span class="line">  <span class="keyword">FROM</span> SalesHistory <span class="keyword">GROUP</span> <span class="keyword">BY</span> sale_date</span><br><span class="line"><span class="keyword">HAVING</span> sale_date <span class="operator">=</span> <span class="string">&#x27;2007-10-01&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 聚合前使用 WHERE 子句过滤</span></span><br><span class="line"><span class="keyword">SELECT</span> sale_date, <span class="built_in">SUM</span>(quantity)</span><br><span class="line">  <span class="keyword">FROM</span> SalesHistory</span><br><span class="line"> <span class="keyword">WHERE</span> sale_date <span class="operator">=</span> <span class="string">&#x27;2007-10-01&#x27;</span> </span><br><span class="line"> <span class="keyword">GROUP</span> <span class="keyword">BY</span> sale_date;</span><br></pre></td></tr></table></figure>

<p>使用第二条语句效率更高，原因主要有两点</p>
<ol>
<li>使用 GROUP BY 子句进行聚合时会进行排序，如果事先通过 WHERE 子句能筛选出一部分行，能减轻排序的钢制</li>
<li>在 WHERE 子句中可以使用索引，而 HAVING 子句是针对聚合后生成的视频进行筛选的，但很多时候聚合后生成的视图并没有保留原表的索引结构</li>
</ol>
<p><strong>四、在 GROUP BY 子句和 ORDER BY 子句中使用索引</strong></p>
<p>GROUP BY 子句和 ORDER BY 子句一般都会进行排序，以对行进行排列和替换，不过如果指定带有索引的列作为这两者的参数列，由于用到了索引，可以实现高速查询，由于索引是有序的，排序本身都会被省略掉</p>
<p><strong>五、使用索引时，条件表达式的左侧应该是原始字段</strong></p>
<p>假设我们在 col 列上建立了索引，则下面这些 SQL 语句无法用到索引</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line">  <span class="keyword">FROM</span> SomeTable</span><br><span class="line"> <span class="keyword">WHERE</span> col <span class="operator">*</span> <span class="number">1.1</span> <span class="operator">&gt;</span> <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line">  <span class="keyword">FROM</span> SomeTable</span><br><span class="line"> <span class="keyword">WHERE</span> SUBSTR(col, <span class="number">1</span>, <span class="number">1</span>) <span class="operator">=</span> <span class="string">&#x27;a&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>以上第一个 SQL 在索引列上进行了运算, 第二个 SQL 对索引列使用了函数，均无法用到索引，正确方式是把列单独放在左侧,如下:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line">  <span class="keyword">FROM</span> SomeTable</span><br><span class="line"> <span class="keyword">WHERE</span> col_1 <span class="operator">&gt;</span> <span class="number">100</span> <span class="operator">/</span> <span class="number">1.1</span>;</span><br></pre></td></tr></table></figure>


<p>当然如果需要对此列使用函数，则无法避免在左侧运算，可以考虑使用函数索引，不过一般不推荐随意这么做。</p>
<p><strong>六、尽量避免使用否定形式</strong></p>
<p>如下的几种否定形式不能用到索引：</p>
<ul>
<li>&lt;&gt;</li>
<li>!&#x3D;</li>
<li>NOT IN</li>
</ul>
<p>所以以下 了SQL 语句会导致全表扫描</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line">  <span class="keyword">FROM</span> SomeTable</span><br><span class="line"> <span class="keyword">WHERE</span> col_1 <span class="operator">&lt;&gt;</span> <span class="number">100</span>;</span><br></pre></td></tr></table></figure>

<p>可以改成以下形式</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line">  <span class="keyword">FROM</span> SomeTable</span><br><span class="line"> <span class="keyword">WHERE</span> col_1 <span class="operator">&gt;</span> <span class="number">100</span> <span class="keyword">or</span> col_1 <span class="operator">&lt;</span> <span class="number">100</span>;</span><br></pre></td></tr></table></figure>

<p><strong>七、进行默认的类型转换</strong></p>
<p>假设 col 是 char 类型，则推荐使用以下第二，三条 SQL 的写法，不推荐第一条 SQL 的写法</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">× <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> SomeTable <span class="keyword">WHERE</span> col_1 <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">○ <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> SomeTable <span class="keyword">WHERE</span> col_1 <span class="operator">=</span> <span class="string">&#x27;10&#x27;</span>;</span><br><span class="line">○ <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> SomeTable <span class="keyword">WHERE</span> col_1 <span class="operator">=</span> <span class="built_in">CAST</span>(<span class="number">10</span>, <span class="keyword">AS</span> <span class="type">CHAR</span>(<span class="number">2</span>));</span><br></pre></td></tr></table></figure>

<p>虽然第一条 SQL 会默认把 10 转成 ‘10’，但这种默认类型转换不仅会增加额外的性能开销，开会导致索引不可用，所以建议使用的时候地进行类型转换。</p>
<p><strong>八、减少中间表</strong></p>
<p>在 SQL 中，子查询的结果会产生一张新表，不过如果不加限制大量使用中间表的话，会带来两个问题，一是展示数据需要消耗内存资源，二是原始表中的索引不容易用到，所以尽量减少中间表也可以提升性能。</p>
<p><strong>九、灵活使用 HAVING 子句</strong></p>
<p>这一点与上面第八条相呼应，对聚合结果指定筛选条件时，使用 HAVING 是基本的原则，可能一些工程师会倾向于使用下面这样的写法:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line">  <span class="keyword">FROM</span> (<span class="keyword">SELECT</span> sale_date, <span class="built_in">MAX</span>(quantity) <span class="keyword">AS</span> max_qty</span><br><span class="line">          <span class="keyword">FROM</span> SalesHistory </span><br><span class="line">         <span class="keyword">GROUP</span> <span class="keyword">BY</span> sale_date) TMP</span><br><span class="line"><span class="keyword">WHERE</span> max_qty <span class="operator">&gt;=</span> <span class="number">10</span>;</span><br></pre></td></tr></table></figure>
<p>虽然上面这样的写法能达到目的，但会生成 TMP 这张临时表，所以应该使用下面这样的写法:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> sale_date, <span class="built_in">MAX</span>(quantity) </span><br><span class="line">  <span class="keyword">FROM</span> SalesHistory</span><br><span class="line"> <span class="keyword">GROUP</span> <span class="keyword">BY</span> sale_date</span><br><span class="line"><span class="keyword">HAVING</span> <span class="built_in">MAX</span>(quantity) <span class="operator">&gt;=</span> <span class="number">10</span>;</span><br></pre></td></tr></table></figure>

<p>HAVING 子句和聚合操作是同时执行的，所以比起生成中间表后再执行 HAVING 子句，效率会更高，代码也更简洁</p>
<p><strong>10、需要对多个字段使用 IN 谓词时，将它们汇总到一处</strong></p>
<p>一个表的多个字段可能都使用了 IN 谓词，如下:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> id, state, city </span><br><span class="line">  <span class="keyword">FROM</span> Addresses1 A1</span><br><span class="line"> <span class="keyword">WHERE</span> state <span class="keyword">IN</span> (<span class="keyword">SELECT</span> state</span><br><span class="line">                   <span class="keyword">FROM</span> Addresses2 A2</span><br><span class="line">                  <span class="keyword">WHERE</span> A1.id <span class="operator">=</span> A2.id) </span><br><span class="line">    <span class="keyword">AND</span> city <span class="keyword">IN</span> (<span class="keyword">SELECT</span> city</span><br><span class="line">                   <span class="keyword">FROM</span> Addresses2 A2 </span><br><span class="line">                  <span class="keyword">WHERE</span> A1.id <span class="operator">=</span> A2.id);</span><br></pre></td></tr></table></figure>

<p>这段代码用到了两个子查询，也就产生了两个中间表，可以像下面这样写</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line">  <span class="keyword">FROM</span> Addresses1 A1</span><br><span class="line"> <span class="keyword">WHERE</span> id <span class="operator">||</span> state <span class="operator">||</span> city</span><br><span class="line">    <span class="keyword">IN</span> (<span class="keyword">SELECT</span> id <span class="operator">||</span> state<span class="operator">||</span> city</span><br><span class="line">          <span class="keyword">FROM</span> Addresses2 A2);</span><br></pre></td></tr></table></figure>

<p>这样子查询不用考虑关联性，没有中间表产生，而且只执行一次即可。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文一开始花了挺大的篇幅来讲解 SQL 的规范，请大家务必重视这部分内部，良好地规范有利于团队协作，对于代码的阅读也比较友好。</p>
<p>之后介绍了一些 SQL 的比较高级的用法，巧用这些技巧确实能达到事半功倍的效果，由于本文篇幅有限只是介绍了一部分，下篇我们会再介绍一些其他的技巧，敬请期待哦</p>
<p><strong>巨人的肩膀</strong></p>
<ul>
<li>&lt;&lt;SQL 进阶教程&gt;&gt;</li>
</ul>
<p>欢迎大家关注公号，共同进步！</p>
<p><img src="https://user-gold-cdn.xitu.io/2020/5/8/171f3cdebc558d86?w=430&h=430&f=jpeg&s=41396"></p>

        
      </div>

         
    </div>
    
     
  </div>
  
    
<nav id="article-nav">
  <a class="article-nav-btn left "
    
      href="/2023/10/30/nsq-Source-code-analysis/"
      title="NSQD源码解析：执行入口分析与核心功能解释"
     >
    <i class="fa-solid fa-angle-left"></i>
    <p class="title-text">
      
        NSQD源码解析：执行入口分析与核心功能解释
        
    </p>
  </a>
  <a class="article-nav-btn right "
    
      href="/2023/09/07/sub-table/"
      title="分库分表--概览"
     >

    <p class="title-text">
      
        分库分表--概览
        
    </p>
    <i class="fa-solid fa-angle-right"></i>
  </a>
</nav>


  
</article>




  <script src="https://cdn.staticfile.org/twikoo/1.6.26/twikoo.all.min.js"></script>
  <div id="comment-card" class="comment-card">
    <div class="main-title-bar">
      <div class="main-title-dot"></div>
      <div class="main-title">Comments </div>
    </div>
    <div id="tcomment"></div>
  </div>
  <script>
      twikoo.init({
          envId: '',
          el: '#tcomment',
          region: '',
          path: 'location.pathname',
          lang: '',
      })
  </script>
  


    </div>
    <div id="footer-wrapper">
      <footer id="footer">
  
  <div id="footer-info" class="inner">
    
    &copy; 2024 Cheny<br>
    Powered by <a href="https://hexo.io/" target="_blank">Hexo</a> & Theme <a target="_blank" rel="noopener" href="https://github.com/saicaca/hexo-theme-vivia">Vivia</a>
  </div>
</footer>

    </div>
    <div class="back-to-top-wrapper">
    <button id="back-to-top-btn" class="back-to-top-btn hide" onclick="topFunction()">
        <i class="fa-solid fa-angle-up"></i>
    </button>
</div>

<script>
    function topFunction() {
        window.scroll({ top: 0, behavior: 'smooth' });
    }
    let btn = document.getElementById('back-to-top-btn');
    function scrollFunction() {
        if (document.body.scrollTop > 600 || document.documentElement.scrollTop > 600) {
            btn.classList.remove('hide')
        } else {
            btn.classList.add('hide')
        }
    }
    window.onscroll = function() {
        scrollFunction();
    }
</script>

  </div>
  <script src="/js/light-dark-switch.js"></script>
</body>
</html>
