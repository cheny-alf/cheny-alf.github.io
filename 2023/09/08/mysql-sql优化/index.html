<!DOCTYPE html>
<html lang="en" color-mode="light">

  <head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  
  <meta name="author" content="John Doe" />
  <meta name="description" content="" />
  
  
  <title>
    
      SQL进阶使用技巧 
      
      
      |
    
     陈sir爱狂扁
  </title>

  
    <link rel="apple-touch-icon" href="/images/favicon.png">
    <link rel="icon" href="/images/favicon.png">
  

  <!-- Raleway-Font -->
  <link href="https://fonts.googleapis.com/css?family=Raleway&display=swap" rel="stylesheet">

  <!-- hexo site css -->
  <link rel="stylesheet" href="/css/main.css" />
  <link rel="stylesheet" href="//at.alicdn.com/t/font_1886449_67xjft27j1l.css" />
  <!-- 代码块风格 -->
  

  <!-- jquery3.3.1 -->
  
    <script defer type="text/javascript" src="/plugins/jquery.min.js"></script>
  

  <!-- fancybox -->
  
    <link href="/plugins/jquery.fancybox.min.css" rel="stylesheet">
    <script defer type="text/javascript" src="/plugins/jquery.fancybox.min.js"></script>
  
  
<script src="/js/fancybox.js"></script>


  

  
    <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
  

  <script>
    var html = document.documentElement
    const colorMode = localStorage.getItem('color-mode')
    if (colorMode) {
      document.documentElement.setAttribute('color-mode', colorMode)
    }
  </script>
<meta name="generator" content="Hexo 6.3.0"></head>


  <body>
    <div id="app">
      <div class="header">
  <div class="avatar">
    <a href="/">
      <!-- 头像取消懒加载，添加no-lazy -->
      
        <img src="/images/avatar.png" alt="">
      
    </a>
    <div class="nickname"><a href="/">陈sir爱狂扁</a></div>
  </div>
  <div class="navbar">
    <ul>
      
        <li class="nav-item" data-path="/">
          <a href="/">主页</a>
        </li>
      
        <li class="nav-item" data-path="/archives/">
          <a href="/archives/">归档</a>
        </li>
      
        <li class="nav-item" data-path="/tags/">
          <a href="/tags/">标签</a>
        </li>
      
        <li class="nav-item" data-path="/friends/">
          <a href="/friends/">朋友</a>
        </li>
      
        <li class="nav-item" data-path="/about/">
          <a href="/about/">关于</a>
        </li>
      
    </ul>
  </div>
</div>


<script src="/js/activeNav.js"></script>



      <div class="flex-container">
        <!-- 文章详情页，展示文章具体内容，url形式：https://yoursite/文章标题/ -->
<!-- 同时为「标签tag」，「朋友friend」，「分类categories」，「关于about」页面的承载页面，具体展示取决于page.type -->


  <!-- LaTex Display -->

  
    <script async type="text/javascript" src="/plugins/mathjax/tex-chtml.js"></script>
  
  <script>
    MathJax = {
      tex: {
        inlineMath: [['$', '$'], ['\\(', '\\)']]
      }
    }
  </script>





  <!-- clipboard -->

  
    <script async type="text/javascript" src="/plugins/clipboard.min.js"></script>
  
  
<script src="/js/codeCopy.js"></script>







  

  

  

  
  <!-- 文章内容页 url形式：https://yoursite/文章标题/ -->
  <div class="container post-details" id="post-details">
    <div class="post-content">
      <div class="post-title">SQL进阶使用技巧</div>
      <div class="post-attach">
        <span class="post-pubtime">
          <i class="iconfont icon-updatetime mr-10" title="Update time"></i>
          2023-09-08 13:51:23
        </span>
        
              <span class="post-tags">
                <i class="iconfont icon-tags mr-10" title="Tags"></i>
                
                <span class="span--tag mr-8">
                  <a href="/tags/mysql/" title="mysql">
                    #mysql
                  </a>
                </span>
                
              </span>
          
      </div>
      <div class="markdown-body">
        <p>好文借鉴学习！！！<br><a target="_blank" rel="noopener" href="https://github.com/allentofight/easy-cs/blob/main/MySQL/SQL%E8%BF%9B%E9%98%B6%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7.md?plain=1">https://github.com/allentofight/easy-cs/blob/main/MySQL/SQL%E8%BF%9B%E9%98%B6%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7.md?plain=1</a><br>由于工作需要，最近做了很多 BI 取数的工作，需要用到一些比较高级的 SQL 技巧，总结了一下工作中用到的一些比较骚的进阶，特此记录一下，以方便自己查阅，主要目录如下：</p>
<ul>
<li>SQL 的书写规范</li>
<li>SQL 的一些进阶使用技巧</li>
<li>SQL 的优化方法</li>
</ul>
<h2 id="SQL-的书写规范"><a href="#SQL-的书写规范" class="headerlink" title="SQL 的书写规范"></a>SQL 的书写规范</h2><p>在介绍一些技巧之前，有必要强调一下规范，这一点我发现工作中经常被人忽略，其实遵循好的规范可读性会好很多，应该遵循哪些规范呢</p>
<p>1、 表名要有意义，且标准 SQL 中规定表名的第一个字符应该是字母。</p>
<p>2、注释，有单行注释和多行注释，如下</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 单行注释</span></span><br><span class="line"><span class="comment">-- 从SomeTable中查询col_1 </span></span><br><span class="line"><span class="keyword">SELECT</span> col_1</span><br><span class="line">  <span class="keyword">FROM</span> SomeTable;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">多行注释</span></span><br><span class="line"><span class="comment">从 SomeTable 中查询 col_1 </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">SELECT</span> col_1</span><br><span class="line">  <span class="keyword">FROM</span> SomeTable;</span><br></pre></td></tr></table></figure>
<p>多行注释很多人不知道，这种写法不用可以用来添加真正的溈，也可以用来注释代码，非常方便</p>
<p>3、缩进</p>
<p>就像写 Java，Python 等编程语言一样 ，SQL 也应该有缩进，良好地缩进对提升代码的可读性帮助很大，以下分别是好的缩进与坏的缩进示例</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 好的缩进</span></span><br><span class="line"><span class="keyword">SELECT</span> col_1, </span><br><span class="line">       col_2, </span><br><span class="line">       col_3,</span><br><span class="line">       <span class="built_in">COUNT</span>(<span class="operator">*</span>) </span><br><span class="line">  <span class="keyword">FROM</span> tbl_A</span><br><span class="line"> <span class="keyword">WHERE</span> col_1 <span class="operator">=</span> <span class="string">&#x27;a&#x27;</span></span><br><span class="line">   <span class="keyword">AND</span> col_2 <span class="operator">=</span> ( <span class="keyword">SELECT</span> <span class="built_in">MAX</span>(col_2)</span><br><span class="line">                   <span class="keyword">FROM</span> tbl_B</span><br><span class="line">                  <span class="keyword">WHERE</span> col_3 <span class="operator">=</span> <span class="number">100</span> )</span><br><span class="line"> <span class="keyword">GROUP</span> <span class="keyword">BY</span> col_1,</span><br><span class="line">          col_2,</span><br><span class="line">          col_3</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 坏的示例</span></span><br><span class="line"><span class="keyword">SELECT</span> col1_1, col_2, col_3, <span class="built_in">COUNT</span>(<span class="operator">*</span>)</span><br><span class="line"><span class="keyword">FROM</span>   tbl_A</span><br><span class="line"><span class="keyword">WHERE</span>  col1_1 <span class="operator">=</span> <span class="string">&#x27;a&#x27;</span></span><br><span class="line"><span class="keyword">AND</span>    col1_2 <span class="operator">=</span> (</span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">MAX</span>(col_2)</span><br><span class="line"><span class="keyword">FROM</span>   tbl_B</span><br><span class="line"><span class="keyword">WHERE</span>  col_3 <span class="operator">=</span> <span class="number">100</span></span><br><span class="line">) <span class="keyword">GROUP</span> <span class="keyword">BY</span> col_1, col_2, col_3</span><br></pre></td></tr></table></figure>

<p>4、空格</p>
<p>代码中应该适当留有一些空格，如果一点不留，代码都凑到一起， 逻辑单元不明确，阅读的人也会产生额外的压力，以下分别是是好的与坏的示例</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">-- 好的示例</span></span><br><span class="line"><span class="keyword">SELECT</span> col_1</span><br><span class="line">  <span class="keyword">FROM</span> tbl_A A, tbl_B B</span><br><span class="line"> <span class="keyword">WHERE</span> ( A.col_1 <span class="operator">&gt;=</span> <span class="number">100</span> <span class="keyword">OR</span> A.col_2 <span class="keyword">IN</span> ( <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span> ) )</span><br><span class="line">   <span class="keyword">AND</span> A.col_3 <span class="operator">=</span> B.col_3;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 坏的示例</span></span><br><span class="line"><span class="keyword">SELECT</span> col_1</span><br><span class="line">  <span class="keyword">FROM</span> tbl_A A,tbl_B B</span><br><span class="line"> <span class="keyword">WHERE</span> (A.col_1<span class="operator">&gt;=</span><span class="number">100</span> <span class="keyword">OR</span> A.col_2 <span class="keyword">IN</span> (<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>))</span><br><span class="line">   <span class="keyword">AND</span> A.col_3<span class="operator">=</span>B.col_3;</span><br></pre></td></tr></table></figure>


<p>4、大小写</p>
<p>关键字使用大小写，表名列名使用小写，如下</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> col_1, col_2, col_3,</span><br><span class="line">       <span class="built_in">COUNT</span>(<span class="operator">*</span>)</span><br><span class="line">  <span class="keyword">FROM</span> tbl_A</span><br><span class="line"> <span class="keyword">WHERE</span> col_1 <span class="operator">=</span> <span class="string">&#x27;a&#x27;</span></span><br><span class="line">   <span class="keyword">AND</span> col_2 <span class="operator">=</span> ( <span class="keyword">SELECT</span> <span class="built_in">MAX</span>(col_2)</span><br><span class="line">                   <span class="keyword">FROM</span> tbl_B</span><br><span class="line">                  <span class="keyword">WHERE</span> col_3 <span class="operator">=</span> <span class="number">100</span> )</span><br><span class="line"> <span class="keyword">GROUP</span> <span class="keyword">BY</span> col_1, col_2, col_3</span><br></pre></td></tr></table></figure>

<p>花了这么多时间强调规范，有必要吗，有！好的规范让代码的可读性更好，更有利于团队合作，之后的 SQL 示例都会遵循这些规范。</p>
<h2 id="SQL-的一些进阶使用技巧"><a href="#SQL-的一些进阶使用技巧" class="headerlink" title="SQL 的一些进阶使用技巧"></a>SQL 的一些进阶使用技巧</h2><p><strong>一、巧用 CASE WHEN 进行统计</strong></p>
<p>来看看如何巧用 CASE WHEN 进行定制化统计,假设我们有如下的需求，希望根据左边各个市的人口统计每个省的人口</p>
<p><img src="https://user-gold-cdn.xitu.io/2020/5/8/171f45f26bc2542d?w=818&h=283&f=png&s=30366"></p>
<p>使用 CASE WHEN 如下</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">CASE</span> pref_name</span><br><span class="line">               <span class="keyword">WHEN</span> <span class="string">&#x27;长沙&#x27;</span> <span class="keyword">THEN</span> <span class="string">&#x27;湖南&#x27;</span> </span><br><span class="line">               <span class="keyword">WHEN</span> <span class="string">&#x27;衡阳&#x27;</span> <span class="keyword">THEN</span> <span class="string">&#x27;湖南&#x27;</span></span><br><span class="line">               <span class="keyword">WHEN</span> <span class="string">&#x27;海口&#x27;</span> <span class="keyword">THEN</span> <span class="string">&#x27;海南&#x27;</span> </span><br><span class="line">               <span class="keyword">WHEN</span> <span class="string">&#x27;三亚&#x27;</span> <span class="keyword">THEN</span> <span class="string">&#x27;海南&#x27;</span></span><br><span class="line">       <span class="keyword">ELSE</span> <span class="string">&#x27;其他&#x27;</span> <span class="keyword">END</span> <span class="keyword">AS</span> district,</span><br><span class="line">       <span class="built_in">SUM</span>(population) </span><br><span class="line"><span class="keyword">FROM</span> PopTbl</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> district;</span><br></pre></td></tr></table></figure>

<p><strong>二、巧用 CASE WHEN 进行更新</strong></p>
<p>现在某公司员人工资信息表如下:</p>
<p><img src="https://user-gold-cdn.xitu.io/2020/5/8/171f45f271f4a96f?w=318&h=280&f=png&s=16778"></p>
<p>现在公司出台了一个奇葩的规定</p>
<ol>
<li>对当前工资为 1 万以上的员工，降薪 10%。</li>
<li>对当前工资低于 1 万的员工，加薪 20%。</li>
</ol>
<p>一些人不假思索可能写出了以下的 SQL:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--条件1</span></span><br><span class="line"><span class="keyword">UPDATE</span> Salaries</span><br><span class="line"><span class="keyword">SET</span> salary <span class="operator">=</span> salary <span class="operator">*</span> <span class="number">0.9</span> <span class="keyword">WHERE</span> salary <span class="operator">&gt;=</span> <span class="number">10000</span>;</span><br><span class="line"><span class="comment">--条件2</span></span><br><span class="line"><span class="keyword">UPDATE</span> Salaries</span><br><span class="line"><span class="keyword">SET</span> salary <span class="operator">=</span> salary <span class="operator">*</span> <span class="number">1.2</span></span><br><span class="line"><span class="keyword">WHERE</span> salary <span class="operator">&lt;</span> <span class="number">10000</span>;</span><br></pre></td></tr></table></figure>
<p>这么做其实是有问题的， 什么问题，对小明来说，他的工资是 10500，执行第一个 SQL 后，工资变为 10500 * 0.9 &#x3D; 9450, 紧接着又执行条件 2， 工资变为了 9450 * 1.2 &#x3D; 11340，反而涨薪了！</p>
<p>如果用 CASE WHEN 可以解决此类问题，如下：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> Salaries</span><br><span class="line"><span class="keyword">SET</span> salary <span class="operator">=</span> <span class="keyword">CASE</span> <span class="keyword">WHEN</span> salary <span class="operator">&gt;=</span> <span class="number">10000</span> <span class="keyword">THEN</span> salary <span class="operator">*</span> <span class="number">0.9</span></span><br><span class="line"><span class="keyword">WHEN</span> salary <span class="operator">&lt;</span> <span class="number">280000</span> <span class="keyword">THEN</span> salary <span class="operator">*</span> <span class="number">1.2</span></span><br><span class="line"><span class="keyword">ELSE</span> salary <span class="keyword">END</span>;</span><br></pre></td></tr></table></figure>

<p><strong>三、巧用 HAVING 子句</strong></p>
<p>一般 HAVING 是与 GROUP BY 结合使用的，但其实它是可以独立使用的，<br>假设有如下表，第一列 seq 叫连续编号，但其实有些编号是缺失的，怎么知道编号是否缺失呢，</p>
<p><img src="https://user-gold-cdn.xitu.io/2020/5/8/171f45f26ba5842c?w=419&h=216&f=png&s=17670"></p>
<p>用 HAVING 表示如下:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="string">&#x27;存在缺失的编号&#x27;</span> <span class="keyword">AS</span> gap</span><br><span class="line">  <span class="keyword">FROM</span> SeqTbl</span><br><span class="line"><span class="keyword">HAVING</span> <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="operator">&lt;&gt;</span> <span class="built_in">MAX</span>(seq);</span><br></pre></td></tr></table></figure>

<p><strong>四、自连接</strong></p>
<p>针对相同的表进行的连接被称为“自连接”(self join)，这个技巧常常被人们忽视，其实是有挺多妙用的</p>
<p>1、删除重复行</p>
<p><img src="https://user-gold-cdn.xitu.io/2020/5/8/171f45f28a9ee43e?w=419&h=273&f=png&s=27006"></p>
<p>上图中有三个橘子，需要把这些重复的行给删掉，用如下自连接可以解决：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> Products P1</span><br><span class="line"> <span class="keyword">WHERE</span> id <span class="operator">&lt;</span> ( <span class="keyword">SELECT</span> <span class="built_in">MAX</span>(P2.id) </span><br><span class="line">                   <span class="keyword">FROM</span> Products P2 </span><br><span class="line">                  <span class="keyword">WHERE</span> P1.name <span class="operator">=</span> P2.name </span><br><span class="line">                    <span class="keyword">AND</span> P1.price <span class="operator">=</span> P2.price ); </span><br></pre></td></tr></table></figure>

<p>2、排序</p>
<p>在 db 中，我们经常需要按分数，人数，销售额等进行排名，有 Oracle, DB2 中可以使用 RANK 函数进行排名，不过在 MySQL 中 RANK 函数未实现，这种情况我们可以使用自连接来实现,如对以下 Products 表按价格高低进行排名</p>
<p><img src="https://user-gold-cdn.xitu.io/2020/5/8/171f45f1ebcb9b3c?w=366&h=175&f=png&s=17002"></p>
<p>使用自连接可以这么写:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 排序从 1 开始。如果已出现相同位次，则跳过之后的位次 </span></span><br><span class="line"><span class="keyword">SELECT</span> P1.name,</span><br><span class="line">       P1.price,</span><br><span class="line">       (<span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(P2.price)</span><br><span class="line">          <span class="keyword">FROM</span> Products P2</span><br><span class="line">         <span class="keyword">WHERE</span> P2.price <span class="operator">&gt;</span> P1.price) <span class="operator">+</span> <span class="number">1</span> <span class="keyword">AS</span> rank_1</span><br><span class="line">  <span class="keyword">FROM</span> Products P1 </span><br><span class="line">  <span class="keyword">ORDER</span> <span class="keyword">BY</span> rank_1;</span><br></pre></td></tr></table></figure>

<p>结果如下:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">name price rank </span><br><span class="line"><span class="comment">----- ------ ------ </span></span><br><span class="line">橘子    <span class="number">100</span>     <span class="number">1</span> </span><br><span class="line">西瓜     <span class="number">80</span>     <span class="number">2</span> </span><br><span class="line">苹果     <span class="number">50</span>     <span class="number">3</span> </span><br><span class="line">葡萄     <span class="number">50</span>     <span class="number">3</span> </span><br><span class="line">香蕉     <span class="number">50</span>     <span class="number">3</span> </span><br><span class="line">柠檬     <span class="number">30</span>     <span class="number">6</span></span><br></pre></td></tr></table></figure>

<p><strong>五、巧用 COALESCE 函数</strong></p>
<p>此函数作用返回参数中的第一个非空表达式，假设有如下商品，我们重新格式化一样，如果 city 为 null，代表商品不在此城市发行，但我们在展示结果的时候不想展示 null，而想展示 ‘N&#x2F;A’, 可以这么做:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> </span><br><span class="line">    <span class="built_in">COALESCE</span>(city, <span class="string">&#x27;N/A&#x27;</span>)</span><br><span class="line">  <span class="keyword">FROM</span></span><br><span class="line">    customers;</span><br></pre></td></tr></table></figure>

<p><img src="https://user-gold-cdn.xitu.io/2020/5/8/171f45f23af2ffa4?w=319&h=281&f=png&s=12891"></p>
<h2 id="SQL-性能优化技巧"><a href="#SQL-性能优化技巧" class="headerlink" title="SQL 性能优化技巧"></a>SQL 性能优化技巧</h2><p><strong>一、参数是子查询时，使用 EXISTS 代替 IN</strong></p>
<p>如果 IN 的参数是（1，2，3）这样的值列表时，没啥问题，但如果参数是子查询时，就需要注意了。比如，现在有如下两个表：</p>
<p><img src="https://user-gold-cdn.xitu.io/2020/5/8/171f45f332825699?w=1406&h=584&f=png&s=47266"></p>
<p>现在我们要查出同时存在于两个表的员工，即小明和小东，则以下用 IN 和 EXISTS 返回的结果是一样，但是用 EXISTS 的 SQL 会更快:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">-- 慢</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> </span><br><span class="line">  <span class="keyword">FROM</span> Class_A</span><br><span class="line"><span class="keyword">WHERE</span> id <span class="keyword">IN</span> (<span class="keyword">SELECT</span> id </span><br><span class="line">               <span class="keyword">FROM</span>  CLASS_B);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 快</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line">  <span class="keyword">FROM</span> Class_A A </span><br><span class="line"> <span class="keyword">WHERE</span> <span class="keyword">EXISTS</span></span><br><span class="line">(<span class="keyword">SELECT</span> <span class="operator">*</span> </span><br><span class="line">   <span class="keyword">FROM</span> Class_B  B</span><br><span class="line">  <span class="keyword">WHERE</span> A.id <span class="operator">=</span> B.id);</span><br></pre></td></tr></table></figure>

<p>为啥使用 EXISTS 的 SQL 运行更快呢，有两个原因</p>
<ol>
<li>可以&#96;用到索引，如果连接列 (id) 上建立了索引，那么查询 Class_B 时不用查实际的表，只需查索引就可以了。</li>
<li>如果使用 EXISTS，那么只要查到一行数据满足条件就会终止查询， 不用像使用 IN 时一样扫描全表。在这一点上 NOT EXISTS 也一样</li>
</ol>
<p>另外如果 IN 后面如果跟着的是子查询，由于 SQL 会先执行 IN 后面的子查询，会将子查询的结果保存在一张临时的工作表里（内联视图），然后扫描<strong>整个视图</strong>，显然扫描整个视图这个工作很多时候是非常耗时的，而用 EXISTS 不会生成临时表。</p>
<p>当然了，如果 IN 的参数是子查询时，也可以用连接来代替，如下：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 使用连接代替 IN SELECT A.id, A.name</span></span><br><span class="line"><span class="keyword">FROM</span> Class_A A <span class="keyword">INNER</span> <span class="keyword">JOIN</span> Class_B B <span class="keyword">ON</span> A.id <span class="operator">=</span> B.id;</span><br></pre></td></tr></table></figure>
<p>用到了 「id」列上的索引，而且由于没有子查询，也不会生成临时表</p>
<p><strong>二、避免排序</strong></p>
<p>SQL 是声明式语言，即对用户来说，只关心它能做什么，不用关心它怎么做。这样可能会产生潜在的性能问题：排序，会产生排序的代表性运算有下面这些</p>
<ul>
<li>GROUP BY 子句</li>
<li>ORDER BY 子句</li>
<li>聚合函数(SUM、COUNT、AVG、MAX、MIN)</li>
<li>DISTINCT</li>
<li>集合运算符(UNION、INTERSECT、EXCEPT)</li>
<li>窗口函数(RANK、ROW_NUMBER 等)</li>
</ul>
<p>如果在内存中排序还好，但如果内存不够导致需要在硬盘上排序上的话，性能就会急剧下降，所以我们需要减少不必要的排序。怎样做可以减少排序呢。</p>
<p>1、 使用集合运算符的 ALL 可选项</p>
<p>SQL 中有 UNION，INTERSECT，EXCEPT 三个集合运算符，默认情况下，这些运算符会为了避免重复数据而进行排序，对比一下使用 UNION 运算符加和不加 ALL 的情况:</p>
<p><img src="https://user-gold-cdn.xitu.io/2020/5/8/171f45f341f95fba?w=974&h=539&f=png&s=49965"></p>
<p>注意：加 ALL 是优化性能非常有效的手段，不过前提是不在乎结果是否有重复数据。</p>
<p>2、使用 EXISTS 代表 DISTINCT</p>
<p>为了排除重复数据， DISTINCT 也会对结果进行排序，如果需要对两张表的连接结果进行去重，可以考虑用 EXISTS 代替 DISTINCT，这样可以避免排序。</p>
<p><img src="https://user-gold-cdn.xitu.io/2020/5/8/171f45f36457dfd3?w=818&h=283&f=png&s=36930"></p>
<p>如何找出有销售记录的商品，使用如下 DISTINCT 可以：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> I.item_no</span><br><span class="line"><span class="keyword">FROM</span> Items I <span class="keyword">INNER</span> <span class="keyword">JOIN</span> SalesHistory SH</span><br><span class="line"><span class="keyword">ON</span> I. item_no <span class="operator">=</span> SH. item_no;</span><br></pre></td></tr></table></figure>

<p>不过更好的方式是使用 EXISTS:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> item_no <span class="keyword">FROM</span> Items I</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">EXISTS</span> </span><br><span class="line">        (<span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line">           <span class="keyword">FROM</span> SalesHistory SH</span><br><span class="line">          <span class="keyword">WHERE</span> I.item_no <span class="operator">=</span> SH.item_no);</span><br></pre></td></tr></table></figure>

<p>既用到了索引，又避免了排序对性能的损耗。</p>
<p><strong>二、在极值函数中使用索引（MAX&#x2F;MIN）</strong></p>
<p>使用 MAX&#x2F; MIN 都会对进行排序，如果参数字段上没加索引会导致全表扫描，如果建有索引，则只需要扫描索引即可，对比如下</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 这样写需要扫描全表 </span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">MAX</span>(item)</span><br><span class="line">  <span class="keyword">FROM</span> Items;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 这样写能用到索引 </span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">MAX</span>(item_no)</span><br><span class="line">  <span class="keyword">FROM</span> Items;</span><br></pre></td></tr></table></figure>

<p>注意：极值函数参数推荐为索引列中并不是不需要排序，而是优化了排序前的查找速度（毕竟索引本身就是有序排列的）。</p>
<p><strong>三、能写在 WHERE 子句里的条件不要写在 HAVING 子句里</strong></p>
<p>下列 SQL 语句返回的结果是一样的:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 聚合后使用 HAVING 子句过滤</span></span><br><span class="line"><span class="keyword">SELECT</span> sale_date, <span class="built_in">SUM</span>(quantity)</span><br><span class="line">  <span class="keyword">FROM</span> SalesHistory <span class="keyword">GROUP</span> <span class="keyword">BY</span> sale_date</span><br><span class="line"><span class="keyword">HAVING</span> sale_date <span class="operator">=</span> <span class="string">&#x27;2007-10-01&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 聚合前使用 WHERE 子句过滤</span></span><br><span class="line"><span class="keyword">SELECT</span> sale_date, <span class="built_in">SUM</span>(quantity)</span><br><span class="line">  <span class="keyword">FROM</span> SalesHistory</span><br><span class="line"> <span class="keyword">WHERE</span> sale_date <span class="operator">=</span> <span class="string">&#x27;2007-10-01&#x27;</span> </span><br><span class="line"> <span class="keyword">GROUP</span> <span class="keyword">BY</span> sale_date;</span><br></pre></td></tr></table></figure>

<p>使用第二条语句效率更高，原因主要有两点</p>
<ol>
<li>使用 GROUP BY 子句进行聚合时会进行排序，如果事先通过 WHERE 子句能筛选出一部分行，能减轻排序的钢制</li>
<li>在 WHERE 子句中可以使用索引，而 HAVING 子句是针对聚合后生成的视频进行筛选的，但很多时候聚合后生成的视图并没有保留原表的索引结构</li>
</ol>
<p><strong>四、在 GROUP BY 子句和 ORDER BY 子句中使用索引</strong></p>
<p>GROUP BY 子句和 ORDER BY 子句一般都会进行排序，以对行进行排列和替换，不过如果指定带有索引的列作为这两者的参数列，由于用到了索引，可以实现高速查询，由于索引是有序的，排序本身都会被省略掉</p>
<p><strong>五、使用索引时，条件表达式的左侧应该是原始字段</strong></p>
<p>假设我们在 col 列上建立了索引，则下面这些 SQL 语句无法用到索引</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line">  <span class="keyword">FROM</span> SomeTable</span><br><span class="line"> <span class="keyword">WHERE</span> col <span class="operator">*</span> <span class="number">1.1</span> <span class="operator">&gt;</span> <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line">  <span class="keyword">FROM</span> SomeTable</span><br><span class="line"> <span class="keyword">WHERE</span> SUBSTR(col, <span class="number">1</span>, <span class="number">1</span>) <span class="operator">=</span> <span class="string">&#x27;a&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>以上第一个 SQL 在索引列上进行了运算, 第二个 SQL 对索引列使用了函数，均无法用到索引，正确方式是把列单独放在左侧,如下:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line">  <span class="keyword">FROM</span> SomeTable</span><br><span class="line"> <span class="keyword">WHERE</span> col_1 <span class="operator">&gt;</span> <span class="number">100</span> <span class="operator">/</span> <span class="number">1.1</span>;</span><br></pre></td></tr></table></figure>


<p>当然如果需要对此列使用函数，则无法避免在左侧运算，可以考虑使用函数索引，不过一般不推荐随意这么做。</p>
<p><strong>六、尽量避免使用否定形式</strong></p>
<p>如下的几种否定形式不能用到索引：</p>
<ul>
<li>&lt;&gt;</li>
<li>!&#x3D;</li>
<li>NOT IN</li>
</ul>
<p>所以以下 了SQL 语句会导致全表扫描</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line">  <span class="keyword">FROM</span> SomeTable</span><br><span class="line"> <span class="keyword">WHERE</span> col_1 <span class="operator">&lt;&gt;</span> <span class="number">100</span>;</span><br></pre></td></tr></table></figure>

<p>可以改成以下形式</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line">  <span class="keyword">FROM</span> SomeTable</span><br><span class="line"> <span class="keyword">WHERE</span> col_1 <span class="operator">&gt;</span> <span class="number">100</span> <span class="keyword">or</span> col_1 <span class="operator">&lt;</span> <span class="number">100</span>;</span><br></pre></td></tr></table></figure>

<p><strong>七、进行默认的类型转换</strong></p>
<p>假设 col 是 char 类型，则推荐使用以下第二，三条 SQL 的写法，不推荐第一条 SQL 的写法</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">× <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> SomeTable <span class="keyword">WHERE</span> col_1 <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">○ <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> SomeTable <span class="keyword">WHERE</span> col_1 <span class="operator">=</span> <span class="string">&#x27;10&#x27;</span>;</span><br><span class="line">○ <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> SomeTable <span class="keyword">WHERE</span> col_1 <span class="operator">=</span> <span class="built_in">CAST</span>(<span class="number">10</span>, <span class="keyword">AS</span> <span class="type">CHAR</span>(<span class="number">2</span>));</span><br></pre></td></tr></table></figure>

<p>虽然第一条 SQL 会默认把 10 转成 ‘10’，但这种默认类型转换不仅会增加额外的性能开销，开会导致索引不可用，所以建议使用的时候地进行类型转换。</p>
<p><strong>八、减少中间表</strong></p>
<p>在 SQL 中，子查询的结果会产生一张新表，不过如果不加限制大量使用中间表的话，会带来两个问题，一是展示数据需要消耗内存资源，二是原始表中的索引不容易用到，所以尽量减少中间表也可以提升性能。</p>
<p><strong>九、灵活使用 HAVING 子句</strong></p>
<p>这一点与上面第八条相呼应，对聚合结果指定筛选条件时，使用 HAVING 是基本的原则，可能一些工程师会倾向于使用下面这样的写法:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line">  <span class="keyword">FROM</span> (<span class="keyword">SELECT</span> sale_date, <span class="built_in">MAX</span>(quantity) <span class="keyword">AS</span> max_qty</span><br><span class="line">          <span class="keyword">FROM</span> SalesHistory </span><br><span class="line">         <span class="keyword">GROUP</span> <span class="keyword">BY</span> sale_date) TMP</span><br><span class="line"><span class="keyword">WHERE</span> max_qty <span class="operator">&gt;=</span> <span class="number">10</span>;</span><br></pre></td></tr></table></figure>
<p>虽然上面这样的写法能达到目的，但会生成 TMP 这张临时表，所以应该使用下面这样的写法:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> sale_date, <span class="built_in">MAX</span>(quantity) </span><br><span class="line">  <span class="keyword">FROM</span> SalesHistory</span><br><span class="line"> <span class="keyword">GROUP</span> <span class="keyword">BY</span> sale_date</span><br><span class="line"><span class="keyword">HAVING</span> <span class="built_in">MAX</span>(quantity) <span class="operator">&gt;=</span> <span class="number">10</span>;</span><br></pre></td></tr></table></figure>

<p>HAVING 子句和聚合操作是同时执行的，所以比起生成中间表后再执行 HAVING 子句，效率会更高，代码也更简洁</p>
<p><strong>10、需要对多个字段使用 IN 谓词时，将它们汇总到一处</strong></p>
<p>一个表的多个字段可能都使用了 IN 谓词，如下:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> id, state, city </span><br><span class="line">  <span class="keyword">FROM</span> Addresses1 A1</span><br><span class="line"> <span class="keyword">WHERE</span> state <span class="keyword">IN</span> (<span class="keyword">SELECT</span> state</span><br><span class="line">                   <span class="keyword">FROM</span> Addresses2 A2</span><br><span class="line">                  <span class="keyword">WHERE</span> A1.id <span class="operator">=</span> A2.id) </span><br><span class="line">    <span class="keyword">AND</span> city <span class="keyword">IN</span> (<span class="keyword">SELECT</span> city</span><br><span class="line">                   <span class="keyword">FROM</span> Addresses2 A2 </span><br><span class="line">                  <span class="keyword">WHERE</span> A1.id <span class="operator">=</span> A2.id);</span><br></pre></td></tr></table></figure>

<p>这段代码用到了两个子查询，也就产生了两个中间表，可以像下面这样写</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line">  <span class="keyword">FROM</span> Addresses1 A1</span><br><span class="line"> <span class="keyword">WHERE</span> id <span class="operator">||</span> state <span class="operator">||</span> city</span><br><span class="line">    <span class="keyword">IN</span> (<span class="keyword">SELECT</span> id <span class="operator">||</span> state<span class="operator">||</span> city</span><br><span class="line">          <span class="keyword">FROM</span> Addresses2 A2);</span><br></pre></td></tr></table></figure>

<p>这样子查询不用考虑关联性，没有中间表产生，而且只执行一次即可。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文一开始花了挺大的篇幅来讲解 SQL 的规范，请大家务必重视这部分内部，良好地规范有利于团队协作，对于代码的阅读也比较友好。</p>
<p>之后介绍了一些 SQL 的比较高级的用法，巧用这些技巧确实能达到事半功倍的效果，由于本文篇幅有限只是介绍了一部分，下篇我们会再介绍一些其他的技巧，敬请期待哦</p>
<p><strong>巨人的肩膀</strong></p>
<ul>
<li>&lt;&lt;SQL 进阶教程&gt;&gt;</li>
</ul>
<p>欢迎大家关注公号，共同进步！</p>
<p><img src="https://user-gold-cdn.xitu.io/2020/5/8/171f3cdebc558d86?w=430&h=430&f=jpeg&s=41396"></p>

      </div>
      
        <div class="prev-or-next">
          <div class="post-foot-next">
            
              <a href="/2023/09/07/sub-table/" target="_self">
                <i class="iconfont icon-chevronleft"></i>
                <span>Prev</span>
              </a>
            
          </div>
          <div class="post-attach">
            <span class="post-pubtime">
              <i class="iconfont icon-updatetime mr-10" title="Update time"></i>
              2023-09-08 13:51:23
            </span>
            
                  <span class="post-tags">
                    <i class="iconfont icon-tags mr-10" title="Tags"></i>
                    
                    <span class="span--tag mr-8">
                      <a href="/tags/mysql/" title="mysql">
                        #mysql
                      </a>
                    </span>
                    
                  </span>
              
          </div>
          <div class="post-foot-prev">
            
          </div>
        </div>
      
    </div>
    
  <div id="btn-catalog" class="btn-catalog">
    <i class="iconfont icon-catalog"></i>
  </div>
  <div class="post-catalog hidden" id="catalog">
    <div class="title">Contents</div>
    <div class="catalog-content">
      
        <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#SQL-%E7%9A%84%E4%B9%A6%E5%86%99%E8%A7%84%E8%8C%83"><span class="toc-text">SQL 的书写规范</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#SQL-%E7%9A%84%E4%B8%80%E4%BA%9B%E8%BF%9B%E9%98%B6%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7"><span class="toc-text">SQL 的一些进阶使用技巧</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#SQL-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E6%8A%80%E5%B7%A7"><span class="toc-text">SQL 性能优化技巧</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-text">总结</span></a></li></ol>
      
    </div>
  </div>

  
<script src="/js/catalog.js"></script>




    
      <div class="comments-container">
        







      </div>
    
  </div>


        
<div class="footer">
  <div class="social">
    <ul>
      
        <li>
          <a title="github" target="_blank" rel="noopener" href="https://github.com/cheny-alf">
            <i class="iconfont icon-github"></i>
          </a>
        </li>
      
    </ul>
  </div>
  
    
    <div class="footer-more">
      
        <a target="_blank" rel="noopener" href="https://github.com/zchengsite/hexo-theme-oranges">Copyright © 2023 Oranges</a>
        
    </div>
  
    
    <div class="footer-more">
      
        <a target="_blank" rel="noopener" href="https://github.com/zchengsite/hexo-theme-oranges">Theme by Oranges | Powered by Hexo</a>
        
    </div>
  
  
    <div class="footer-views">
      
          本站总访问量<span id="busuanzi_value_site_pv"></span>次
        
      
          本文总阅读量<span id="busuanzi_value_page_pv"></span>次
        
      
      
    </div>
  
</div>

      </div>

      <div class="tools-bar">
        <div class="back-to-top tools-bar-item hidden">
  <a href="javascript: void(0)">
    <i class="iconfont icon-chevronup"></i>
  </a>
</div>


<script src="/js/backtotop.js"></script>



        
  <div class="search-icon tools-bar-item" id="search-icon">
    <a href="javascript: void(0)">
      <i class="iconfont icon-search"></i>
    </a>
  </div>

  <div class="search-overlay hidden">
    <div class="search-content" tabindex="0">
      <div class="search-title">
        <span class="search-icon-input">
          <a href="javascript: void(0)">
            <i class="iconfont icon-search"></i>
          </a>
        </span>
        
          <input type="text" class="search-input" id="search-input" placeholder="Search...">
        
        <span class="search-close-icon" id="search-close-icon">
          <a href="javascript: void(0)">
            <i class="iconfont icon-close"></i>
          </a>
        </span>
      </div>
      <div class="search-result" id="search-result"></div>
    </div>
  </div>

  <script type="text/javascript">
    var inputArea = document.querySelector("#search-input")
    var searchOverlayArea = document.querySelector(".search-overlay")

    inputArea.onclick = function() {
      getSearchFile()
      this.onclick = null
    }

    inputArea.onkeydown = function() {
      if(event.keyCode == 13)
        return false
    }

    function openOrHideSearchContent() {
      let isHidden = searchOverlayArea.classList.contains('hidden')
      if (isHidden) {
        searchOverlayArea.classList.remove('hidden')
        document.body.classList.add('hidden')
        // inputArea.focus()
      } else {
        searchOverlayArea.classList.add('hidden')
        document.body.classList.remove('hidden')
      }
    }

    function blurSearchContent(e) {
      if (e.target === searchOverlayArea) {
        openOrHideSearchContent()
      }
    }

    document.querySelector("#search-icon").addEventListener("click", openOrHideSearchContent, false)
    document.querySelector("#search-close-icon").addEventListener("click", openOrHideSearchContent, false)
    searchOverlayArea.addEventListener("click", blurSearchContent, false)

    var searchFunc = function (path, search_id, content_id) {
      'use strict';
      var $input = document.getElementById(search_id);
      var $resultContent = document.getElementById(content_id);
      $resultContent.innerHTML = "<ul><span class='local-search-empty'>First search, index file loading, please wait...<span></ul>";
      $.ajax({
        // 0x01. load xml file
        url: path,
        dataType: "xml",
        success: function (xmlResponse) {
          // 0x02. parse xml file
          var datas = $("entry", xmlResponse).map(function () {
            return {
              title: $("title", this).text(),
              content: $("content", this).text(),
              url: $("url", this).text()
            };
          }).get();
          $resultContent.innerHTML = "";

          $input.addEventListener('input', function () {
            // 0x03. parse query to keywords list
            var str = '<ul class=\"search-result-list\">';
            var keywords = this.value.trim().toLowerCase().split(/[\s\-]+/);
            $resultContent.innerHTML = "";
            if (this.value.trim().length <= 0) {
              return;
            }
            // 0x04. perform local searching
            datas.forEach(function (data) {
              var isMatch = true;
              var content_index = [];
              if (!data.title || data.title.trim() === '') {
                data.title = "Untitled";
              }
              var orig_data_title = data.title.trim();
              var data_title = orig_data_title.toLowerCase();
              var orig_data_content = data.content.trim().replace(/<[^>]+>/g, "");
              var data_content = orig_data_content.toLowerCase();
              var data_url = data.url;
              var index_title = -1;
              var index_content = -1;
              var first_occur = -1;
              // only match artiles with not empty contents
              if (data_content !== '') {
                keywords.forEach(function (keyword, i) {
                  index_title = data_title.indexOf(keyword);
                  index_content = data_content.indexOf(keyword);

                  if (index_title < 0 && index_content < 0) {
                    isMatch = false;
                  } else {
                    if (index_content < 0) {
                      index_content = 0;
                    }
                    if (i == 0) {
                      first_occur = index_content;
                    }
                    // content_index.push({index_content:index_content, keyword_len:keyword_len});
                  }
                });
              } else {
                isMatch = false;
              }
              // 0x05. show search results
              if (isMatch) {
                str += "<li><a href='" + data_url + "' class='search-result-title'>" + orig_data_title + "</a>";
                var content = orig_data_content;
                if (first_occur >= 0) {
                  // cut out 100 characters
                  var start = first_occur - 20;
                  var end = first_occur + 80;

                  if (start < 0) {
                    start = 0;
                  }

                  if (start == 0) {
                    end = 100;
                  }

                  if (end > content.length) {
                    end = content.length;
                  }

                  var match_content = content.substr(start, end);

                  // highlight all keywords
                  keywords.forEach(function (keyword) {
                    var regS = new RegExp(keyword, "gi");
                    match_content = match_content.replace(regS, "<span class=\"search-keyword\">" + keyword + "</span>");
                  });

                  str += "<p class=\"search-result-abstract\">" + match_content + "...</p>"
                }
                str += "</li>";
              }
            });
            str += "</ul>";
            if (str.indexOf('<li>') === -1) {
              return $resultContent.innerHTML = "<ul><span class='local-search-empty'>No result<span></ul>";
            }
            $resultContent.innerHTML = str;
          });
        },
        error: function(xhr, status, error) {
          $resultContent.innerHTML = ""
          if (xhr.status === 404) {
            $resultContent.innerHTML = "<ul><span class='local-search-empty'>The search.xml file was not found, please refer to：<a href='https://github.com/zchengsite/hexo-theme-oranges#configuration' target='_black'>configuration</a><span></ul>";
          } else {
            $resultContent.innerHTML = "<ul><span class='local-search-empty'>The request failed, Try to refresh the page or try again later.<span></ul>";
          }
        }
      });
      $(document).on('click', '#search-close-icon', function() {
        $('#search-input').val('');
        $('#search-result').html('');
      });
    }

    var getSearchFile = function() {
        var path = "/search.xml";
        searchFunc(path, 'search-input', 'search-result');
    }
  </script>




        
  <div class="tools-bar-item theme-icon" id="switch-color-scheme">
    <a href="javascript: void(0)">
      <i id="theme-icon" class="iconfont icon-moon"></i>
    </a>
  </div>

  
<script src="/js/colorscheme.js"></script>





        
  
    <div class="share-icon tools-bar-item">
      <a href="javascript: void(0)" id="share-icon">
        <i class="iconfont iconshare"></i>
      </a>
      <div class="share-content hidden">
        
          <a class="share-item" href="https://twitter.com/intent/tweet?text=' + SQL%E8%BF%9B%E9%98%B6%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7 + '&url=' + https%3A%2F%2Fcheny-alf.github.io%2F2023%2F09%2F08%2Fmysql-sql%25E4%25BC%2598%25E5%258C%2596%2F + '" target="_blank" title="Twitter">
            <i class="iconfont icon-twitter"></i>
          </a>
        
        
          <a class="share-item" href="https://www.facebook.com/sharer.php?u=https://cheny-alf.github.io/2023/09/08/mysql-sql%E4%BC%98%E5%8C%96/" target="_blank" title="Facebook">
            <i class="iconfont icon-facebooksquare"></i>
          </a>
        
      </div>
    </div>
  
  
<script src="/js/shares.js"></script>



      </div>
    </div>
  </body>
</html>
