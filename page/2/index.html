<!DOCTYPE html><html lang="zh-CN" id="theme-light-mode"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="author" content="Yourname"><title>陈sir爱狂扁</title><meta name="description" content="A simple and beautiful blog"><meta name="keywords" content="Blog,博客,Hexo"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="renderer" content="webkit"><link rel="shortcut icon" type="image/x-icon" href="/images/favicon.webp"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/blog_basic.css"><link rel="stylesheet" href="/css/font-awesome.min.css"><link rel="stylesheet" href="/css/insight.css"><link rel="stylesheet" href="/css/search.css"><link rel="alternate" type="application/atom+xml" title="ATOM 1.0" href="/atom.xml"><script src="/js/jquery.js"></script><meta name="generator" content="Hexo 6.3.0"></head><body><div class="page-top animated fadeInDown"><div class="nav"><li> <a href="/">Home</a></li><li> <a href="/archives">Archives</a></li><li> <a href="/tags">Tags</a></li><li> <a href="/about">About</a></li><li> <a href="/links">Links</a></li></div><div class="information"><div class="nav_right_btn"><li><a class="fa fa-chevron-left" onclick="window.history.go(-1)" style="display:none;"> </a></li><li><a class="fa fa-search" onclick="openWindow();"></a></li><li><a class="fa fa-sun-o" onclick="darkLightToggle();"></a></li></div><div class="avatar"><img src="/images/logo.webp"></div></div></div><div class="sidebar animated fadeInDown"><div class="sidebar-top"><div class="logo-title"><div class="title"><img src="/images/logo@2x.webp" style="width:220px;" alt="favicon"><h3 title=""><a href="/">陈sir爱狂扁</a></h3><div class="description"><p>A simple and beautiful blog</p></div></div><ul class="social-links"><li><a target="_blank" rel="noopener" href="https://github.com/Lhcfl"><i class="fa fa-github"></i></a></li><li><a href="mailto:yourname@example.com"><i class="fa fa-envelope"></i></a></li></ul></div></div><div class="footer"><div class="p"> <span> 全站CC-BY-SA-3.0 </span><i class="fa fa-star"></i><span> Yourname</span></div><div class="by_farbox"><span>Powered by </span><a href="https://hexo.io/zh-cn/" target="_blank">Hexo </a><span> & </span><a href="https://github.com/Lhcfl/hexo-theme-anatolo" target="_blank">Anatolo </a></div><div class="beian"></div></div></div><div class="main"><div class="autopagerize_page_element"><div class="content"><div class="post animated fadeInDown"><div class="post-title"><h3><a href="/2023/08/31/transfor/">golang 替换string中的emoji、英文符号等</a></h3></div><div class="post-content"><div class="card"><p><p>闲话不多说，今天我们主要解决的问题就是在golang中<strong>如何替换字符串中的emoji、英文符号、中文符号、数字</strong>。主要的解决办法还是通过正则表达式哈！</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;net/url&quot;</span></span><br><span class="line">	<span class="string">&quot;regexp&quot;</span></span><br><span class="line">	<span class="string">&quot;strings&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> ChinsesPuncts = []<span class="type">string</span>&#123;</span><br><span class="line">	<span class="string">&quot;，&quot;</span>, <span class="string">&quot;。&quot;</span>, <span class="string">&quot;、&quot;</span>, <span class="string">&quot;！&quot;</span>, <span class="string">&quot;？&quot;</span>, <span class="string">&quot;：&quot;</span>, <span class="string">&quot;；&quot;</span>, <span class="string">&quot;﹑&quot;</span>, <span class="string">&quot;•&quot;</span>, <span class="string">&quot;＂&quot;</span>, <span class="string">&quot;…&quot;</span>, <span class="string">&quot;‘&quot;</span>, <span class="string">&quot;’&quot;</span>, <span class="string">&quot;“&quot;</span>, <span class="string">&quot;”&quot;</span>, <span class="string">&quot;〝&quot;</span>, <span class="string">&quot;〞&quot;</span>,</span><br><span class="line">	<span class="string">&quot;∕&quot;</span>, <span class="string">&quot;¦&quot;</span>, <span class="string">&quot;‖&quot;</span>, <span class="string">&quot;—&quot;</span>, <span class="string">&quot;　&quot;</span>, <span class="string">&quot;〈&quot;</span>, <span class="string">&quot;〉&quot;</span>, <span class="string">&quot;﹞&quot;</span>, <span class="string">&quot;﹝&quot;</span>, <span class="string">&quot;「&quot;</span>, <span class="string">&quot;」&quot;</span>, <span class="string">&quot;‹&quot;</span>, <span class="string">&quot;›&quot;</span>, <span class="string">&quot;〖&quot;</span>, <span class="string">&quot;〗&quot;</span>, <span class="string">&quot;】&quot;</span>, <span class="string">&quot;【&quot;</span>, <span class="string">&quot;»&quot;</span>, <span class="string">&quot;«&quot;</span>, <span class="string">&quot;』&quot;</span>,</span><br><span class="line">	<span class="string">&quot;『&quot;</span>, <span class="string">&quot;〕&quot;</span>, <span class="string">&quot;〔&quot;</span>, <span class="string">&quot;》&quot;</span>, <span class="string">&quot;《&quot;</span>, <span class="string">&quot;﹐&quot;</span>, <span class="string">&quot;¸&quot;</span>, <span class="string">&quot;﹕&quot;</span>, <span class="string">&quot;︰&quot;</span>, <span class="string">&quot;﹔&quot;</span>, <span class="string">&quot;！&quot;</span>, <span class="string">&quot;¡&quot;</span>, <span class="string">&quot;？&quot;</span>, <span class="string">&quot;¿&quot;</span>, <span class="string">&quot;﹖&quot;</span>, <span class="string">&quot;﹌&quot;</span>, <span class="string">&quot;﹏&quot;</span>, <span class="string">&quot;﹋&quot;</span>, <span class="string">&quot;＇&quot;</span>, <span class="string">&quot;´&quot;</span>,</span><br><span class="line">	<span class="string">&quot;ˊ&quot;</span>, <span class="string">&quot;ˋ&quot;</span>, <span class="string">&quot;―&quot;</span>, <span class="string">&quot;﹫&quot;</span>, <span class="string">&quot;︳&quot;</span>, <span class="string">&quot;︴&quot;</span>, <span class="string">&quot;¯&quot;</span>, <span class="string">&quot;＿&quot;</span>, <span class="string">&quot;￣&quot;</span>, <span class="string">&quot;﹢&quot;</span>, <span class="string">&quot;﹦&quot;</span>, <span class="string">&quot;﹤&quot;</span>, <span class="string">&quot;‐&quot;</span>, <span class="string">&quot;­&quot;</span>, <span class="string">&quot;˜&quot;</span>, <span class="string">&quot;﹟&quot;</span>, <span class="string">&quot;￥&quot;</span>, <span class="string">&quot;﹩&quot;</span>, <span class="string">&quot;﹠&quot;</span>, <span class="string">&quot;﹪&quot;</span>,</span><br><span class="line">	<span class="string">&quot;﹡&quot;</span>, <span class="string">&quot;﹨&quot;</span>, <span class="string">&quot;﹍&quot;</span>, <span class="string">&quot;﹉&quot;</span>, <span class="string">&quot;﹎&quot;</span>, <span class="string">&quot;﹊&quot;</span>, <span class="string">&quot;ˇ&quot;</span>, <span class="string">&quot;︵&quot;</span>, <span class="string">&quot;︶&quot;</span>, <span class="string">&quot;︷&quot;</span>, <span class="string">&quot;︸&quot;</span>, <span class="string">&quot;︹&quot;</span>, <span class="string">&quot;︿&quot;</span>, <span class="string">&quot;﹀&quot;</span>, <span class="string">&quot;︺&quot;</span>, <span class="string">&quot;︽&quot;</span>, <span class="string">&quot;︾&quot;</span>, <span class="string">&quot;ˉ&quot;</span>, <span class="string">&quot;﹁&quot;</span>, <span class="string">&quot;﹂&quot;</span>,</span><br><span class="line">	<span class="string">&quot;﹃&quot;</span>, <span class="string">&quot;﹄&quot;</span>, <span class="string">&quot;︻&quot;</span>, <span class="string">&quot;︼&quot;</span>, <span class="string">&quot;（&quot;</span>, <span class="string">&quot;）&quot;</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ReplaceEmoji 去除句子中的emoji表情</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ReplaceEmoji</span><span class="params">(sentence <span class="type">string</span>)</span></span> <span class="type">string</span> &#123;</span><br><span class="line">	sentence = strings.TrimSpace(sentence)</span><br><span class="line">	<span class="keyword">if</span> sentence == <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">&quot;&quot;</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> regexp.MustCompile(<span class="string">`[\p&#123;So&#125;\p&#123;Sk&#125;]`</span>).ReplaceAllString(sentence, <span class="string">&quot;&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ReplacePunct 去除句子中的标点符号</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ReplacePunct</span><span class="params">(sentence <span class="type">string</span>)</span></span> <span class="type">string</span> &#123;</span><br><span class="line">	sentence = strings.TrimSpace(sentence)</span><br><span class="line">	<span class="keyword">if</span> sentence == <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">&quot;&quot;</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 去掉英文标点符号</span></span><br><span class="line">	sentence = regexp.MustCompile(<span class="string">`[[:punct:]\s]`</span>).ReplaceAllString(sentence, <span class="string">&quot;&quot;</span>)</span><br><span class="line">	sentence = url.QueryEscape(sentence)</span><br><span class="line">	sentence = regexp.MustCompile(getChinsesPunctExp()).ReplaceAllString(sentence, <span class="string">&quot;&quot;</span>)</span><br><span class="line">	sentence, _ = url.QueryUnescape(sentence)</span><br><span class="line">	<span class="keyword">return</span> sentence</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回中文标点符号的正则表达式</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getChinsesPunctExp</span><span class="params">()</span></span> <span class="type">string</span> &#123;</span><br><span class="line">	<span class="keyword">var</span> chars []<span class="type">string</span></span><br><span class="line">	<span class="keyword">for</span> _, c := <span class="keyword">range</span> ChinsesPuncts &#123;</span><br><span class="line">		chars = <span class="built_in">append</span>(chars, url.QueryEscape(c))</span><br><span class="line">	&#125;</span><br><span class="line">	str := strings.Join(chars, <span class="string">&quot;|&quot;</span>)</span><br><span class="line">	<span class="keyword">return</span> <span class="string">&quot;(&quot;</span> + str + <span class="string">&quot;)&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 去除掉数字</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ReplaceNumeric</span><span class="params">(sentence <span class="type">string</span>)</span></span> <span class="type">string</span> &#123;</span><br><span class="line">	sentence = strings.TrimSpace(sentence)</span><br><span class="line">	<span class="keyword">if</span> sentence == <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">&quot;&quot;</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> regexp.MustCompile(<span class="string">`[0-9]`</span>).ReplaceAllString(sentence, <span class="string">&quot;&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	ReplacePunct(<span class="string">&quot;大家好ab!！！这是替换后的&quot;</span>)</span><br><span class="line">	ReplacePunct(<span class="string">&quot;hello!this is a test demo&quot;</span>)</span><br><span class="line">	ReplaceEmoji(<span class="string">&quot;😀 🆒 how are you? 🌞&quot;</span>)</span><br><span class="line">	ReplaceNumeric(<span class="string">&quot;这是1，2，3，4&quot;</span>)</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</p></div></div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2023-08-31</span><a class="tag" href="/categories/Golang/" title="Golang">Golang </a><i class="fa fa-tag"></i><a class="tag" href="/tags/Golang/" title="Golang">Golang </a><span class="leancloud_visitors"></span><span>About 594 words, 1 min 58 sec  read</span></div></div></div></div><div class="post animated fadeInDown"><div class="post-title"><h3><a href="/2023/08/16/dailyread1/">每日阅读--mutex的发展</a></h3></div><div class="post-content"><div class="card"><p><p>解决并发访问的场景在我们的开发的过程中是非常常见的，比如多个goroutine同时访问同一个资源，如计数器、秒杀系统、往同一个buffer中写入数据等等，如果没有互斥控制，就会产生一些异常的状况，比如计数器计数不准，秒杀商品超卖，buffer中数据混乱等。</p>
<p>面对这些问题，在go语言中怎么解决呢？就是用<code>互斥锁</code>mutex！</p>
<h3 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h3><p><strong>临界区</strong>:就是一个被共享的资源，或者说是一个整体的一组共享资源比如对数据库的访问、对某一个共享数据结构的操作、对一个 I&#x2F;O 设备的使用、对一个连接池中的连接的调用等等。</p>
<p><strong>互斥锁</strong>:就是保证在同一时刻只有一个线程可以访问我们的临界区。当临界区由一个线程持有的时候，其它线程如果想进入这个临界区，就会返回失败，或者是等待。直到持有的线程退出临界区，这些等待线程中的某一个才有机会接着持有这个临界区。</p>
<p><strong>并发原语</strong>:原语，一般是指由若干条指令组成的程序段，用来实现某个特定功能，在执行过程中不可被中断。go官方的并发原语有goroutine、sync包下的Mutex、RWMutex、Once、WaitGroup、Cond、channel、Pool、Context、Timer、atomic等等</p>
<h3 id="进入正题"><a href="#进入正题" class="headerlink" title="进入正题"></a>进入正题</h3><p>假设我们当前有个场景是启动10个线程，每个线程去对count进行10万次+1操作。<br>我们在不加锁的情况下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;sync&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> count = <span class="number">0</span></span><br><span class="line">	<span class="comment">// 使用WaitGroup等待10个goroutine完成</span></span><br><span class="line">	<span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">	wg.Add(<span class="number">10</span>)</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">			<span class="keyword">defer</span> wg.Done()</span><br><span class="line">			<span class="comment">// 对变量count执行10次加1</span></span><br><span class="line">			<span class="keyword">for</span> j := <span class="number">0</span>; j &lt; <span class="number">100000</span>; j++ &#123;</span><br><span class="line">				count++</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;()</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 等待10个goroutine完成</span></span><br><span class="line">	wg.Wait()</span><br><span class="line">	fmt.Println(count)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这段代码中我们采用sync.WaitGroup来等待所有的协程都执行结束再输出最后的结果，但我们在每次运行上面但代码但时候，结果都会不尽如人意，没有得到我们想要都一百万，而接下来我们采用加锁的方式来试一下</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;sync&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 互斥锁保护计数器</span></span><br><span class="line">    <span class="keyword">var</span> mu sync.Mutex</span><br><span class="line">    <span class="comment">// 计数器的值</span></span><br><span class="line">    <span class="keyword">var</span> count = <span class="number">0</span></span><br><span class="line">    <span class="comment">// 辅助变量，用来确认所有的goroutine都完成</span></span><br><span class="line">    <span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">    wg.Add(<span class="number">10</span>)</span><br><span class="line">    <span class="comment">// 启动10个gourontine</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">            <span class="keyword">defer</span> wg.Done()</span><br><span class="line">            <span class="comment">// 累加10万次</span></span><br><span class="line">            <span class="keyword">for</span> j := <span class="number">0</span>; j &lt; <span class="number">100000</span>; j++ &#123;</span><br><span class="line">                mu.Lock()</span><br><span class="line">                count++</span><br><span class="line">                mu.Unlock()</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;()</span><br><span class="line">	&#125;</span><br><span class="line">    wg.Wait()</span><br><span class="line">    fmt.Println(count)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这里我们可以看到，我们声明了一个互斥锁mutex，并且在每次操作count前对他进行Lock,而在操作结束后便进行UnLock。最后看运行结果，达到了我们期望的一百万。这是为什么呢？</p>
<p>其实是因为count++这个操作并不是原子操作，它包含很多步操作，比如先读取这个变量、再修改这个值、再将结果保存到count中。因为不是原子操作，所有在并发的情况下就会出现问题。比如10个协程同时读取到了count的值为8784，然后执行+1，变为8785，再将其写入到count变量中去，最终这个值是8785，但实际上它应该增加10才对，很多但计数操作都被”掩盖”掉了</p>
<p>所以我们通过加锁的方式，限制count只能被1个线程数操作。count++就是我们的临界区，我们只需在临界区前面加锁，在临界区后面释放掉锁就好了。</p>
</p></div></div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2023-08-16</span><a class="tag" href="/categories/Golang/" title="Golang">Golang </a><i class="fa fa-tag"></i><a class="tag" href="/tags/Golang/" title="Golang">Golang </a><span class="leancloud_visitors"></span><span>About 982 words, 3 min 16 sec  read</span></div></div></div></div><div class="post animated fadeInDown"><div class="post-title"><h3><a href="/2023/08/09/hello-world/">Hello World</a></h3></div><div class="post-content"><div class="card"><p><p>Welcome to <a target="_blank" rel="noopener" href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a target="_blank" rel="noopener" href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a target="_blank" rel="noopener" href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a target="_blank" rel="noopener" href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
</p></div></div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2023-08-09</span><span class="leancloud_visitors"></span><span>About 75 words, 15 sec  read</span></div></div></div></div><div class="post animated fadeInDown"><div class="post-title"><h3><a href="/2023/07/11/limiter/">常见的限流方案与实现</a></h3></div><div class="post-content"><div class="card"><p><p>限流指的是系统在面对高并发、大流量的场景下，采用一些手段来限制新的流量对系统对访问，从而保证我们服务对稳定性。<br>常见对算法有 <code>计数器算法、漏斗算法以及令牌桶算法</code>，下面我们分别对这三种算法进行介绍与实现。<br>注：本次实现采用 golang + redis</p>
<h3 id="限流方案"><a href="#限流方案" class="headerlink" title="限流方案"></a>限流方案</h3><p>假设我们当前要完成一个关于限流的需求，要求某个接口一分钟内最多只能请求100次，并且采用redis实现。</p>
<h4 id="计数器算法"><a href="#计数器算法" class="headerlink" title="计数器算法"></a>计数器算法</h4><p>计数器算法相对来说是比较简单的一种限流算法，它又分为固定窗口和滑动窗口两种算法～ </p>
<ul>
<li>固定窗口<br>固定窗口算法指的是维护一个单位时间内的计数器counter，每个请求进来了就让counter + 1，如果在当前时间内，counter达到了阈值，就拒绝后面的请求，等待下一个时间窗口的时候再将counter重新置为0。对于我们的需求来说，就是维护一个单位时间为1分钟的时间窗口，如果在这一分钟内，counter的值超过了100，就拒绝后续的请求。等当前这个1分钟过去后再重置counter的值为0。<br>这个方法存在的问题：因为它的时间并不是动态的1分钟，而是固定好的时间线，所以如果在这一分钟的最后时间内突然有大量的请求，迅速打满了限制，随后就到了下一个一分钟<br>将计数器重置为0后又迅速的打满了限制。那当前这一分钟内的请求数量，达到了限制的两倍。即<code>临界值问题</code>。<br>具体实现如下<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure></li>
<li>滑动窗口<br>滑动窗口算法的是实现方式有很多种，比如说将时间窗口分成多个小单元，每个单元是很小的时间窗口，假设把60秒分成5个小单元，每个单元占12秒，然后再把每请求限制划分到小单元中，也就是每个单元20个请求，每过12秒将窗口向前移动一个单元。这样来实现动态的效果，但这个实现方式实际上还是固定窗口但实现方式，只是去将窗口变小了，<br>还是会存在上述的问题。<br>我们在这里提供另一种思路，就是采用redis的ZSet数据结构，我们将请求的时间戳作为score，将当前时间-60秒作为我们的时间窗口，窗口之前的请求全部删除掉，然后我们 zset获取到的数量就是我们单元时间内的计数值。这个窗口会随着时间而移动，就成为了我们的滑动窗口。<br>具体实现如下<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="漏斗算法"><a href="#漏斗算法" class="headerlink" title="漏斗算法"></a>漏斗算法</h4><p>我们可以从名字中得到关键字<code>漏斗</code>，它是用来比喻这个算法的实现思路。首先漏斗是具备一个固定的容量，同时它会漏水也可以进水，如果水满了，想再进水就要等漏水口把水流出。如果漏斗流水的速率 &lt; 灌水的速率，那么漏斗最后将被灌满，漏斗满了就要等水流出去，腾出空间让其他的水进来。当然在我们的实现算法中，除了漏斗容量外还需要漏斗剩余空间，流水速率，上次流水时间。漏斗剩余空间代表当前情况下是否还可以继续处理请求，流水速率代表我们请求频率的限制，我们当前就是需要100&#x2F;min，上次流水时间用于计算和当前时间的差值，然后用这个时间差计算这段时间漏斗流出了多少的水，腾出了多少的空间。<br><br>具体实现如下<br></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="令牌桶算法"><a href="#令牌桶算法" class="headerlink" title="令牌桶算法"></a>令牌桶算法</h4><p>令牌桶算法和漏斗限流实现起来大同小异，它以固定速度往一个桶内添加令牌，当桶内装满令牌后就停止。这个令牌即是我们的流量单位，按我们的需求来说就是拿到一个令牌就能发起一次请求。同时，我们的令牌桶结构还是能用 hash 类型存储。那么咱们废话少说，直接来看示例：<br><br>具体实现如下<br></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

</p></div></div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2023-07-11</span><i class="fa fa-tag"></i><a class="tag" href="/tags/golang/" title="golang">golang </a><i class="fa fa-tag"></i><a class="tag" href="/tags/redis/" title="redis">redis </a><i class="fa fa-tag"></i><a class="tag" href="/tags/限流/" title="限流">限流 </a><span class="leancloud_visitors"></span><span>About 1200 words, 4 min 0 sec  read</span></div></div></div></div><div class="post animated fadeInDown"><div class="post-title"><h3><a href="/2023/04/10/delay-queue/">基于 Redis 实现的支持延时/定时投递的消息队列</a></h3></div><div class="post-content"><div class="card"><p><h3 id="基于-Redis-实现的支持延时-定时投递的消息队列"><a href="#基于-Redis-实现的支持延时-定时投递的消息队列" class="headerlink" title="基于 Redis 实现的支持延时&#x2F;定时投递的消息队列"></a>基于 Redis 实现的支持延时&#x2F;定时投递的消息队列</h3></p></div></div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2023-04-10</span><a class="tag" href="/categories/延迟队列/" title="延迟队列">延迟队列 </a><a class="tag" href="/categories/延迟队列/Redis/" title="Redis">Redis </a><a class="tag" href="/categories/延迟队列/Redis/Golang/" title="Golang">Golang </a><i class="fa fa-tag"></i><a class="tag" href="/tags/Golang/" title="Golang">Golang </a><i class="fa fa-tag"></i><a class="tag" href="/tags/延迟队列/" title="延迟队列">延迟队列 </a><i class="fa fa-tag"></i><a class="tag" href="/tags/Redis/" title="Redis">Redis </a><span class="leancloud_visitors"></span><span>About 21 words, 4 sec  read</span></div></div></div></div><div class="post animated fadeInDown"><div class="post-title"><h3><a href="/2023/03/26/kafka-interview/">kafka-interview</a></h3></div><div class="post-content"><div class="card"><p><p>&emsp;&emsp;&emsp;这是一篇关于Kafka面试题的文章，主要是记录本人在面试过程中常见的一些题目以及自己认为可能会考察的面试题。当然里面的内容也是用我自己的话术来总结的，可能存在不严谨的地方，还望指出！！！</p>
<h2 id="Kafka"><a href="#Kafka" class="headerlink" title="Kafka"></a>Kafka</h2><p>构成：</p>
<ul>
<li>生产者：向broker发送消息的客户端。</li>
<li>消费者：从broker获取消息的客户端</li>
<li>消费者组：由多个消费者组成，消费者组内每个消费者负责不同分区的数据，一个分区只能由一个组内消费者消费，未声明消费者组的消费者所有的消费者都属于一个组。</li>
<li>Borker：一台kafka服务器就是一个broker，一个集群由多个broker组成，一个broker可以容纳多个topic。</li>
<li>Topic：可以理解为一个队列，生产者和消费者面向的都是一个topic。</li>
<li>Partation分区：一个topic可以分为多个partition，每个partition是一个有序队列。</li>
<li>Replica副本，一个topic的每个分区都有若干个副本（1leader和多个follower）</li>
<li>Leader：生产者发送数据以及消费者消费数据都是leader。</li>
<li>follower：主要负责实时同步数据，以备不时之需。</li>
</ul>
<p><strong>为什么说kafka快</strong><br>采用分区来提高并行度<br>高效的文件数据结构，采用稀疏索引，在读取数据的时候可以快速定位。<br>顺序读写磁盘</p>
<p><strong>分区的好处：</strong>1.可以合理的存储，实现负载均衡。2.可以提高并行度</p>
<p><strong>副本的作用</strong> 提高数据的可靠性，主要也是备份的作用。</p>
<p><strong>ACK的设置与作用</strong><br>0：表示不需要收到leader的ack的应答就发送下一个(高吞吐，低一致性)<br>1：表示只要收到leader应答就发下一个（默认）<br>-1：表示要收到leader和isr的应答才发送下一个</p>
<p><strong>数据重复的情况：</strong> 当ack应答设置为-1时，生产者发来消息，leader和isr队列所有节点都同步完数据之后，leader在做应答的时候挂了，此时需要重新选leader，选完之后生产者又发送了一次这个消息，就会发生重复。</p>
<p><em>解决：</em> 我们可以通过kafka的幂等性来解决这个问题，kafka通过三个id保证消息的不重复，分别是生产者ID，还有一个递增的序列号。保证这两个个不同时相同即可判断消息是否重复。<br>ProducerID：在每个新的Producer初始化时，会被分配一个唯一的ProducerID，这个ProducerID对客户端使用者是不可见的。<br>SequenceNumber：对于每个ProducerID，Producer发送数据的每个Topic和Partition都对应一个从0开始单调递增的SequenceNumber值。<br>参考地址：<a target="_blank" rel="noopener" href="https://juejin.cn/post/7172897190627508237">https://juejin.cn/post/7172897190627508237</a></p>
<p><strong>数据有序是如何保证的</strong><br>kafka是保证单分区内数据是有序的，全局中是没办法保证有序的，然后单分区有序是通过消息的seqNumber来实现的，如果需要做到全局有序的话，那就是设置一个topic对应一个分区就好，然后消费者也可以设置成单线程的，这样的话就可以避免消费端乱序了。</p>
<p><strong>kafka的选举机制</strong><br>满足在ISR中存活，然后按照副本集合的排列顺序，依次选举。<br>ISR：保持和leader同步的follower集合，（in sync replica）<br>OSR：落后于leader的副本集合 （out sync replica）</p>
<p><strong>leader故障后处理细节</strong><br>当leader阶段发生故障之后，从ISR中重新选取一个leader之后，为了保证多个副本之间的一致，会把所有follower的log文件中高于高水位线的部分都截取掉，然后从新的leader中再去同步。<br>高水位线：hw（high water）是所有副本中最小的offset位置。</p>
<p><strong>文件存储结构</strong><br>kafka发送数据之后，kafka是如何进行存储的？<br>kafka中的topic是逻辑上的概念，而partation是物理上的概念，实际上的数据存储是每个partition对应1个log文件夹，然后这个log文件夹存储的就是生产者发送的数据，数据会以追加的形式不断添加，同时，为了防止log文件过大，采用分段的方式，将partition分为多个segment段，每个segment对应有log，index，timeindex文件，这样可以通过小文件快速的定期删除或者删除已经消费完的数据。<br><strong>如何通过offset查找数据：</strong><br>首先，index和log文件的文件名是以当前segment的第一条消息的offset命名的，然后查找的时候就可以通过二分查找的方式来找到当前index文件和log文件。<br>然后，通过index文件找到对应的数据在log文件中的大致的位置，向下遍历直到找到对应的记录<br><strong>消费者与分区的分配方式：</strong><br>range：就是均匀分配，每个消费者去消费几个分区<br>roundRobin：轮询分配，依次分配<br>sticky：粘性分区，</p>
<p><strong>offset的作用</strong><br>用于标示当前分区中的偏移量，消费到哪里了。然后维护offset有两种方式：1.自动提交 2.手动提交</p>
<p><strong>漏消费的情况</strong><br>先提交offset，后消费可能发生漏消费<br><strong>重复消费</strong><br>已经消费了，但是offset没有提交<br><strong>解决办法</strong> 我们将消费消息和提交offset的过程做原子绑定。保证全部执行或者全部不执行。</p>
<p><strong>消息堆积</strong><br>1。说明消费能力不行：可以增加消费者的数量，同时我们也可以增加topic的分区的数量。让消费者数和分区数一致<br>2。我们可能每批次拉取的数据少，然后导致拉取数据的速度小于生产数据的速度，导致积压，我们可以提高每批次拉取数据的量。</p>
</p></div></div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2023-03-26</span><a class="tag" href="/categories/Kafka/" title="Kafka">Kafka </a><i class="fa fa-tag"></i><a class="tag" href="/tags/面试/" title="面试">面试 </a><i class="fa fa-tag"></i><a class="tag" href="/tags/Kafka/" title="Kafka">Kafka </a><span class="leancloud_visitors"></span><span>About 1644 words, 5 min 28 sec  read</span></div></div></div></div><div class="post animated fadeInDown"><div class="post-title"><h3><a href="/2023/03/20/redis-cache/">redis-面试-持久化、淘汰策略等</a></h3></div><div class="post-content"><div class="card"><p><h2 id="内存淘汰策略"><a href="#内存淘汰策略" class="headerlink" title="内存淘汰策略"></a>内存淘汰策略</h2><p>Redis 中提供了 8 种内存淘汰策略：</p>
<ul>
<li>volatile-lru：针对设置了过期时间的 key，使用 LRU 算法进行淘汰</li>
<li>allkeys-lru：针对所有 key 使用 LRU 算法进行淘汰</li>
<li>volatile-lfu：针对设置了过期时间的 key，使用 LFU 算法进行淘汰</li>
<li>allkeys-lfu：针对所有 key 使用 LFU 算法进行淘汰</li>
<li>volatile-random: 从设置了过期时间的 key 中随机删除</li>
<li>allkeys-random: 从所有 key 中随机删除</li>
<li>volatile-ttl：删除最近过期的 key</li>
<li>noeviction（默认策略）：不删除 key，返回 OOM 错误，只能读取不能写入</li>
</ul>
<p>Redis中采用的LRU算法是<strong>近似LRU算法</strong>，首先LRU是证选择最久未访问的 key 进行淘汰，近似 LRU 算法是对少量 key 进行采样（默认为 5 个），将采样 key 放入一个淘汰池中，淘汰池默认最多存储 16 个 key，每轮淘汰循环淘汰采样 key 中访问时间最早的 key，直到释放足够的内存空间。Redis不使用真正的 LRU 实现的原因是真正的 LRU 实现需要更多的内存。（终究还是内存太贵啊~）</p>
<p>Redis中采用的LFU算法是<strong>近似LFU算法</strong>,在 LFU 模式下，Redis 会尝试跟踪记录 key 的访问频率，因此将很少使用的 key 淘汰。这意味着经常使用的 key 更有可能保留在内存中。<strong>LFU 近似算法</strong>：它使用 “Morris 计数器” 近似计数算法来估计对象访问频率，核心思想就是令访问频率+1 是有概率的，且访问频率越高时要 +1 概率越小。</p>
<p>为什么 Redis 需要<strong>淘汰池</strong>？<br>淘汰池，用于存储采样到的样本。对于lru,lfu,ttl类型的淘汰策略，会为采样出来的 key 计算一个评估用的值，取名为 idle。lru 的 idle 是当前和最后一次访问的时间间隔，lfu 的 idle 需要根据当前和最后一次访问的时间间隔和对象的访问频度来做计算，而 ttl 的 idle 就是距离过期时间还有多少毫秒，总的来说， idle 越小则表示 key 越热。当淘汰池满了，会淘汰 idle 最小的数据，也就是将下标为 0 的样本从淘汰池中移除掉，其余样本向前移动一个位置。淘汰池按 idle 升序排列，每次采样结束后，从淘汰池末尾开始向前遍历，找到idle 最大的 key 并将它删除。<br>具体是什么作用呢？<strong>1. 提升淘汰的精准度：</strong> 当进行过几轮淘汰后，淘汰池将会被装满，每次淘汰能进行比较的样本数就变多了。那么样本数越多，当然淘汰越精准。<strong>2. 提升性能</strong>： 淘汰池是一种空间换时间的操作。假如没有淘汰池，那么需要提高每轮采样数才能取得很好的淘汰精准度，而每轮采样数调整得越多，性能也就越差。而淘汰池的存在能让每轮少量采样到后面也能得到很好的淘汰精准度，并不需要提高每轮采样数，从而也就节省了每轮淘汰开销，从另一个角度来说就是提升了性能。</p>
<h2 id="过期Key的删除策略"><a href="#过期Key的删除策略" class="headerlink" title="过期Key的删除策略"></a>过期Key的删除策略</h2><p>定时删除：在设置 key 的过期时间时，同时创建一个定时事件，当时间到达时，由事件处理器自动执行 key 的删除操作。<br>惰性删除；不主动删除过期键，每次从数据库访问 key 时，都检测 key 是否过期，如果过期则删除该 key。<br>定期删除；每隔一段时间「随机」从数据库中取出一定数量的 key 进行检查，并删除其中的过期key。</p>
<p>为什么删除了很多 key 内存占用还是很高？</p>
<ul>
<li>如果使用了 unlink 进行删除，那么很可能是因为大部分 key 的内存还未来得及被异步回收。</li>
<li>如果使用了 del 进行删除，内存占用仍然还是很高，那么可能配置项 <code>lazyfree_lazy_user_del</code> 不为 0，此时 del 也会使用懒惰删除的方式，那么原因就可能和上面说的一样了。</li>
</ul>
<h2 id="缓存穿透，缓存击穿，缓存雪崩问题"><a href="#缓存穿透，缓存击穿，缓存雪崩问题" class="headerlink" title="缓存穿透，缓存击穿，缓存雪崩问题"></a>缓存穿透，缓存击穿，缓存雪崩问题</h2><ol>
<li><strong><em>缓存穿透</em></strong><br>什么是缓存穿透： 用户查询不存在的数据。<br>缓存穿透会有什么问题： 如果出现大量查询不存在数据的请求，轻则增加数据库压力，重则将数据库打 垮。<br>解决方案：</li>
</ol>
<ul>
<li>校验参数： 适用于能够界定一个合法查询范围的场景，直接屏蔽范围外的非法参数。</li>
<li>缓存空值： 这是一种通用的做法，把查询结果为空值的参数也缓存下来，下次查询时就可以直接从缓存取出空值返回。</li>
<li>布隆过滤器<br><strong><em>缓存击穿</em></strong><br>什么是缓存击穿： 用户查询缓存已失效的数据。<br>缓存击穿会有什么问题： 如果出现大量查询缓存已失效的数据，轻则增加数据库压力，重则将数据库打垮。<br>解决方案：</li>
<li>分布式锁： 当查询发现缓存不存在时，在缓存中设置关于该 key 的分布式锁，从数据库查询到结果并更新缓存后解锁。在第一个查询解锁之前，其余查询相同 key 的线程只能阻塞等待解锁，此时解锁后可以直接从缓存获取数据。</li>
<li>热点缓存不过期： 如果能发现什么数据是热点的话，可以不设置过期时间。比如做社交平台的话，我们可以让百万粉丝以上大 v 的用户信息等缓存不会过期。</li>
<li>续期： 缓存被访问时我们就为它进行续期，也可以访问次数到一个阈值后再进行续期，从而让热点缓存不要失效。（但是冷门数据过期后，突然有大量查询的场景这个方案是防不住的）<br><strong><em>缓存雪崩</em></strong><br>什么是缓存雪崩： 大量热点数据同时失效。<br>缓存雪崩会有什么问题： 如果出现大量热点数据同时失效，随后这些热点数据还在被大量查询，轻则增加数据库压力，重则将数据库打垮。<br>解决方案：</li>
<li>分布式锁： 讲过啦！</li>
<li>热点缓存不过期： 讲过啦！</li>
<li>续期： 讲过啦！</li>
<li>过期时间加随机数： 更新缓存并设置过期时间的时候，不要固定过期时间，选用一个固定值 + 随机值，让缓存不要在同一时间过期。</li>
</ul>
<h2 id="持久化"><a href="#持久化" class="headerlink" title="持久化"></a>持久化</h2><ol>
<li>RDB(Redis Database)是 Redis 的持久化机制之一，中文一般叫它内存快照。<br><strong>RDB 存储形式</strong>： RDB 是以二进制形式存储数据的。<br><strong>RDB 生成时机</strong>： RDB 可以执行 SAVE（同步保存） 或者 BGSAVE（创建子进程后台保存）命令主动开始 RDB 的持久化过程。除此之外，RDB 还有被动持久化策略，被动持久化是由服务器定时任务（ServerCron）检查并执行的，该策略可以自己在 redis.conf 配置文件中进行配置，默认被动持久化时机如下：</li>
</ol>
<ul>
<li>900 秒内发生 1 次修改，距离上次保存超过 900 秒后则创建子进程进行 RDB 持久化。</li>
<li>300 秒内发生 10 次修改，距离上次保存超过 300 秒后则创建子进程进行 RDB 持久化。</li>
<li>60 秒内发生 10000 次修改，距离上次保存超过 60 秒后则创建子进程进行 RDB 持久化。<br><strong>RDB 如何存储</strong>： RDB 存储时首先创建一个临时文件，先写入 REDIS + RDB 版本号，再写入一些关于服务器当前状态和 RDB 文件的辅助信息，之后遍历所有数据库（Redis 有 16 个库）里的键值对，为每个键值对选择合适的编码，能压缩存储的就压缩，将它们以二进制形式写入 RDB 临时文件。<br><strong>RDB 生成时写入数据怎么办</strong>： 这个问题实际上是操作系统解决的，操作系统用的是写时复制（Copy-On-Write） 机制，父子进程共享的内存是只读的，如果哪一个进程要写入，则会将发生写入的页拷贝一份（谁写谁拷贝），修改自己的页表内容，之后在拷贝的页上修改数据。RDB 生成在 COW 机制下，父进程最多会复制一倍的内存。<br><strong>RDB 的优点：</strong></li>
<li>RDB 以二进制形式存储数据，并且尽量选择压缩数据存储，所以 RDB 文件一个优点是节省空间。</li>
<li>RDB 是数据库在某个时刻的内存快照，恢复速度快。<br><strong>RDB 的缺点：</strong></li>
<li>由于 COW 机制的存在，如果在后台生成 RDB 时写入数据较多会比较消耗性能和内存空间。</li>
<li>RDB 被动持久化策略会有丢失部分新数据的风险。 虽然可以自己配置策略，但一般也不会令 RDB 持久化得太频繁，生成越频繁性能越差。</li>
</ul>
<ol start="2">
<li>AOF（Append-Only-Files） 是可以看作是一种增量日志文件，日志的内容是以 RESP 协议格式（Redis 设计的网络传输格式）保存的写命令。默认不开启 AOF 持久化，需要修改配置文件开启。<br>**<em>AOF 写入时机</em>**： 每次执行完写操作的命令都会将该命令以 RESP 协议格式写入 AOF 缓冲区。<br>always：(每次执行完都写入)Redis 在每轮事件循环的前置处理函数中，将 AOF 缓冲区中的所有内容通过 write 系统调用函数追加写入 AOF 文件（此时在内核缓冲区），随后立即调用 fsync 系统调用函数将内核缓冲区的内容刷盘。该策略可靠性最好，但是性能最低。<br>everysec：(每秒写入)Redis 在每轮事件循环的前置处理函数中，将 AOF 缓冲区中的内容通过 write 系统调用函数追加写入 AOF 文件（此时在内核缓冲区），如果距离上次刷盘超过 1s ，就向 AOF FSYNC 类型的后台线程提交一个刷盘任务。everysec 是默认 AOF 刷盘策略，该策略在性能和可靠性都是适中的。<br>no： (不主动写入)Redis 在每轮事件循环的前置处理函数中，将 AOF 缓冲区中的内容通过 write 系统调用函数追加写入 AOF 文件（此时在内核缓冲区），不主动调用 fsync，让刷盘时机由操作系统控制。性能最好，可靠性最低。<br>**<em>AOF 重写</em>**： 创建一个子进程，创建一个临时文件，遍历每个数据库，分析每个键值对的内容和状态，用对应的设置命令写入临时文件。临时文件写完后，用配置的 AOF 文件名将其重命名，最后关闭子进程。<br><strong>AOF 需要重写的原因：</strong> AOF 文件记录了很多写命令，其中可能有很多是针对同个 key 的写命令，但是一般来说只有最后一次修改有效，所以我们记录了很多无效命令，这会导致占用很多的内存空间。所以 AOF重写的好处就是能够节省 AOF 文件的占用空间，同时剔除了无效命令还能使恢复速度加快。<br><strong>AOF 重写时机：</strong></li>
</ol>
<ul>
<li>使用 BGREWRITEAOF 命令主动执行后台重写。</li>
<li>AOF 文件占用空间到达上次重写的 2 倍，被动执行后台重写。<br>注：AOF 重写时如果父进程有数据写入，那么也是通过写时复制机制来保证数据安全的。还有，AOF 只有后台进程重写，没有在主进程重写的。<br>_AOF 的优点_：<br>AOF 数据完整性较 RDB 更好。<br><em>AOF 的缺点：</em><br>AOF 文件记录写命令，并不使用二进制形式和压缩存储，占用空间较大。<br>AOF 机制下通过执行记录的命令来进行数据恢复，恢复速度较慢。</li>
</ul>
<ol start="3">
<li>混合持久化：混合持久化是 Redis 4.0 推出的功能，它是在 AOF 文件里前面存储 RDB 格式数据，后面存储 AOF 格式数据。 数据恢复的时候先根据 RDB 部分快速恢复，再根据 AOF 部分靠执行命令恢复数据。</li>
<li>MP-AOF（Multi Part-AOF）是 Redis 7 推出的 AOF 机制。它将 AOF 分成了四类文件：<br>基本文件（Base）： Base 文件是执行 AOF 重写生成的文件，有 RDB 和 AOF 两种格式，默认是生成RDB 文件，清单文件中只会有一个 Base 文件。Base 文件名格式为： {配置 AOF 文件名}.{序列号}.base.rdb 或 {配置 AOF 文件名}.{序列号}.base.aof 。（感觉基本文件叫起来很怪，所以直接叫Base）<br>增量文件（Incr）： Incr 文件是最近一次 AOF 重写后记录的所有写命令。清单文件中可能会有多个Incr 文件，Incr 文件在 AOF 重写时创建，但如果 AOF 重写中途中止了，重试重写的时候又会创建一个 Incr文件来记录新的写命令。Incr 文件名格式为： {配置 AOF 文件名}.{序列号}.incr.aof 。（我们提到增量文件也不用中文名，而是说 Incr）<br>历史文件（History）： 当 AOF 重写成功之后，之前的 base 和 incr 文件将成为历史文件。 历史文件会通过后台线程异步删除。<br>清单文件（Manifest）： 清单文件用于跟踪和管理其余类型的文件，记录格式为： <code>file &#123;文件名&#125; seq &#123;序列号&#125; type &#123;文件类型首字母&#125; </code>。<br><strong>MP-AOF 解决什么问题：</strong></li>
</ol>
<ul>
<li>减少 AOF 重写期间记录写命令带来的内存开销： 之前的 AOF 机制如果在 AOF 重写期间收到写命令，是将这些命令存储在内存中，待重写完成后再把这些命令追加写入 AOF 文件。那么，如果重写期间收到大量写命令的话，存储这些命令将是一笔不小的内存开销。而 MP-AOF 在 AOF 重写期间是创建了一个新的Incr 文件，用来记录重写期间以及之后收到的写命令，于是就减少了内存开销。</li>
<li>减少 AOF 重写时的硬盘 IO 次数： 之前的 AOF 机制为了尽量减少重写完成后，重写期间的写命令占用内存太多，所以会让执行 AOF 重写的子进程把一些重写期间的写命令写入文件，子进程完成重写任务后调用 fsync 刷盘并关闭文件，AOF 重写完成后再将剩余的命令写入重写后的文件，最后再调用一次 fsync 保证落盘。所以和 MP-AOF 在重写期间专门创建一个 Incr 文件来写入命令相比，旧机制硬盘 IO 次数更多了。</li>
<li>AOF 重写完成后不造成主进程阻塞： 之前的 AOF 机制由于将重写期间的写命令存到内存，那么重写完成后需要把内存中剩余的命令追加写入 AOF 文件并调用 fsync 刷盘，如果需要写的命令很多则可能会导致主进程阻塞。而 MP-AOF 在重写期间创建一个新的 Incr 文件来记录之后的写命令，和平时的 AOF 文件一样边写边刷盘（和配置的持久化策略有关），不会重写完成时突然要将大量命令写入文件中。</li>
</ul>
<p><strong>AOF 开启了 always 策略能保证命令一定都落盘吗？</strong><br>很遗憾，并不能。首先，写 AOF 缓冲区，AOF 写文件 + 刷盘和执行命令这三样就不在同一个函数里,写 AOF 缓冲区是执行完命令之后，AOF 写文件 + 刷盘时机是每一轮事件循环的前置处理函数，虽然执行完命令到刷盘这个时间间隔很短很短，但是从理论上讲这个时候宕机还是会丢数据的。如果说已经调用 write写入内核缓冲区了，操作系统没挂后面还能让操作系统自动 fsync 刷盘，但是调用 write 之前已经挂了就没救了。同时不止是考虑这个时间间隔，fsync 之后就把事情交给硬件了，有没有成功落盘也要考虑硬件因素。</p>
</p></div></div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2023-03-20</span><a class="tag" href="/categories/Redis/" title="Redis">Redis </a><i class="fa fa-tag"></i><a class="tag" href="/tags/面试/" title="面试">面试 </a><i class="fa fa-tag"></i><a class="tag" href="/tags/Redis/" title="Redis">Redis </a><span class="leancloud_visitors"></span><span>About 4550 words, 15 min 10 sec  read</span></div></div></div></div><div class="post animated fadeInDown"><div class="post-title"><h3><a href="/2023/03/20/redis/">redis-面试-基本数据结构</a></h3></div><div class="post-content"><div class="card"><p><p>&emsp;&emsp;&emsp;这是一篇关于redis面试题的文章，主要是记录本人在面试过程中常见的一些题目以及自己认为可能会考察的面试题。当然里面的内容也是用我自己的话术来总结的，可能存在不严谨的地方，还望指出！！！</p>
<h2 id="基础数据类型以及对应的底层实现"><a href="#基础数据类型以及对应的底层实现" class="headerlink" title="基础数据类型以及对应的底层实现"></a>基础数据类型以及对应的底层实现</h2><p><strong>string「key-value」结构</strong><br>string是一个比较通用的数据结构，可以存储json，字符串、数字等等，我们使用它来存储一些统计信息啊、计数啊或者一些静态资源等。<br><strong>hash 「key-field-value」结构</strong><br>我们一般将有多个属性的结构使用 Hash 类型进行存储，比如有 id，用户名，性别等属性的用户信息<br><strong>list 「key-value-value。。。」结构</strong><br>我们可以利用list来实现列表相关的内容，比如我们将某地区的48小时的停车难度存入list中。<br><strong>set 「key-value-value。。。」</strong><br>我们可以用 Set 来实现标签功能，比如记录一个文章的标签我们使用 Set 类型，向该集合内添加标签 id，之后获取该集合所有成员即可取出该文章关联的所有标签。<br><strong>zset sortedset 「key-score-value-score-value。。。」</strong><br>zset 最典型的一个应用是排行榜，比如我们使用 Zset 做一个视频点赞排行榜，score 负责存储点赞数，member 为视频 id.</p>
<p>基本数据结构<br><strong><em>SDS</em></strong><br>为什么要有sds？<br>1.redis是c实现的，然后c如果要存储字符串的话是存储char数组或者char指针，如果想要获取字符串的长度，就要遍历字符串，找到他的结束符，效率很低，不适合 Redis 这样用于高并发场景的数据库。同时这样的字符串也不适合动态扩展，因为没有记录它被分配的内存是多少。此外，不记录长度和分配内存空间的话，扩展字符串也容易造成缓冲区溢出。而 SDS 通过空间预分配和惰性空间释放策略减少了修改字符串带来的内存重分配次数。<br>2.SDS 还是二进制安全的。二进制安全指的是 SDS API 都是以处理二进制的方式来处理字符串内容的，程序不会对其中的数据做任何限制、过滤、或者假设，数据在写入时是什么样的，它被读取时就是什么样。<br>SDS底层结构：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">struct __attribute__ ((__packed__)) sdshdr32 &#123;</span><br><span class="line">    uint32_t len; /* 已使用的长度 */</span><br><span class="line">    uint32_t alloc; /* buf 分配内存空间，不包含空终止符号(\0) */</span><br><span class="line">    unsigned char flags; /* 标志位，3位最低有效位表示类型, 其余5个比特位未被使用 */</span><br><span class="line">    char buf[];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>SDS 预分配空间和惰性释放空闲空间策略<br>预分配空间策略： sds预分配空间 指的是在buf数组后面分配一些未使用的空间大小，当后面字符串内容变长的时候可以减少内存分配。预分配空间策略为：新增长度 &lt; 1MB ，则按新长度的两倍分配；新增后长度&gt;&#x3D; 1MB ，则按新长度 + 1MB 进行分配。<br>惰性释放空间空闲策略：惰性释放空闲空间这里指的是释放 buf[] 尾部空闲空间。它会在 Redis 的一些 SDS 类型缓冲区空闲过久或过多时触发，也可以由客户端触发，当 SDS 的 API 需要缩短 SDS 保存的字符串时，程序并不立即使用内存重分配来回收缩短后多出来的字节，而是使用 free 属性将这些字节的数量记录起来，并等待将来使用。<br><strong><em>ZipList</em></strong><br>结构如下：分别是总字节数、尾节点偏移量、元素数量、对应的元素以及结束标识符。元素的结构为：prelen 记录上一个元素的长度、编码方式和数据<br><img src="/../images/ziplist.png" alt="img.png"><br>连锁更新问题：由于 ziplist entry 记录的是上一个 entry 的长度，所以会触发连锁更新。 当 ziplist entry 上一个节点大小 &lt; 254 字节时用 1 字节记录长度， &gt;&#x3D; 254 时用 5 字节记录长度。那么如果出现一种极端情况，连续好多个 entry 大小都为 253 字节，那么前面第一个 entry 因为修改超过了254 字节时，prelen 也会扩大成 5 字节，随后后面的 entry 也会因为前面的大小超过 254 字节而扩大自己的 prelen，这就是“连锁更新”。<br><strong><em>Listpack</em></strong><br>结构如下：分别是总字节数、元素数量、对应元素以及结束标示。元素的结构为当前元素的编码、数据以及长度<br><img src="/../images/listpack.png" alt="img.png"><br>如何解决连锁更新问题： listpack 因为只记录自己的长度，所以更新不会影响其它节点，也就解决了“连锁更新”问题。<br><strong><em>Intset</em></strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">typedef struct intset &#123;</span><br><span class="line">    /* 编码, 记录整数集合底层数组(contents)的类型*/</span><br><span class="line">    uint32_t encoding;</span><br><span class="line">    /* 记录整数集合包含的元素个数 */</span><br><span class="line">    uint32_t length;</span><br><span class="line">    /* 整数集合的底层实现, 虽声明为 int8_t 类型,但真正的类型取决于 encoding */</span><br><span class="line">    int8_t contents[];</span><br><span class="line">&#125; intset;</span><br></pre></td></tr></table></figure>
<p>很简单，整数集合结构体只有三个成员：编码，长度，数据。它的特点是可以减少不必要的内存分配和快速查找元素是否存在，缺点在于插入和删除性能较差。<br>如何减少不必要的内存分配： 整数集合根据所存储的元素最大值确定编码，编码有三种：INTSET_ENC_INT16，INTSET_ENC_INT32，INTSET_ENC_INT64，它们分别对应 16 位，32 位，64 位整数，根据最大元素所占用空间来分配每个元素所占用的空间。比如当最大的元素只是 16 位范围内的整数时，那么整数集合为每个元素分配 2B 的空间来进行保存即可。同时在判断整数是否存在时，若要查询的整数大于编码范围还可以快速判断元素不存在。<br>如何快速查找元素是否存在： 整数集合所保存的数据是有序的（从小到大），所以内部可以使用二分查找提升查询速度。<br>插入和删除性能较差： 插入元素时若该元素大于编码支持的最大值，则需要进行升级，选择一个可以容纳新元素的最小编码。升级时需要进行内存重分配并调整每个元素的偏移量，不过无论升不升级，插入和删除时都涉及 content 数组的内存分配（增加和减少），Redis 并没有为整数集合做预分配内存，原因应该是整数集合是元素数量较少时使用的内部编码，所以尽量节省内存空间。另外，为了保证有序，所以插入和删除时若操作的元素在中间，还需要调整之后元素的位置。所以插入和删除的**最差时间复杂度为 O(n)。<br><strong><em>Dict</em></strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">struct dict &#123;</span><br><span class="line">    dictType *type; /* 字典类型，8 bytes */</span><br><span class="line">    dictEntry **ht_table[2]; /* 哈希表数组 */</span><br><span class="line">    unsigned long ht_used[2]; /* 哈希表拥有键值对数量 */</span><br><span class="line">    long rehashidx; /* rehash 进度/下标 */</span><br><span class="line">    /* 将小尺寸的变量置于结构体的尾部, 减少对齐产生的额外空间开销. */</span><br><span class="line">    int16_t pauserehash; /* rehash 是否暂停， &gt; 0 表示暂停 */</span><br><span class="line">    signed char ht_size_exp[2]; /* 哈希表大小的指数表示，即哈希表大小 = 2 ** exp */</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>dict数组其实维护了两个哈希表，平时使用的是下标为 0 的哈希表，当触发扩容或缩容而进行 rehash（重哈希）时，会将下标为 0 的哈希表作为旧哈希表，下标为 1 的哈希表作为新哈希表。旧哈希表的键值对会逐渐迁移至新哈希表，当旧哈希表的键值对数量为 0 时则说明迁移结束，此时将下标为 0 的哈希表释放，并把新哈希表变为下标 0。<br>接下来我们继续看 dictEntry 结构体：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">typedef struct dictht &#123;</span><br><span class="line">    dictEntry **table; // 8 bytes</span><br><span class="line">    unsigned long size; // 8 bytes</span><br><span class="line">    unsigned long sizemask; // 8 bytes</span><br><span class="line">    unsigned long used; // 8 bytes</span><br><span class="line">&#125; dictht;</span><br></pre></td></tr></table></figure>
<p>由一个哈希表数组，哈希表数组大小的long值，一个用于计算索引的哈希表大小掩码以及已使用的节点数构成，这个哈希表数组，存放的是哈希节点dicEntry，我们会将key-value键值对给它放进去。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">typedef struct dictEntry &#123;</span><br><span class="line">    void *key;  //存放key值</span><br><span class="line">    union &#123;</span><br><span class="line">        void *val;    //存放value值</span><br><span class="line">        uint64_t u64;    //uint64_t整数</span><br><span class="line">        int64_t s64;    //int64_t整数</span><br><span class="line">    &#125;v;</span><br><span class="line">    struct dictEntry *next;    //指向下个哈希表节点，形成链表</span><br><span class="line">&#125;dictEntry;</span><br></pre></td></tr></table></figure>
<p>扩缩容：当哈希表保存当键值对太多或者太少就要通过rehash进行相应当扩容或者收缩。<br>触发时机：<br><code># 负载因子 = 哈希表已保存节点数量 / 哈希表大小 load_factor = ht[0].used / ht[0].size</code><br>a.服务器目前没有在执行 BGSAVE 命令或者 BGREWRITEAOF 命令， 并且哈希表的负载因子大于等于 1 ；<br>b.服务器目前正在执行 BGSAVE 命令或者 BGREWRITEAOF 命令， 并且哈希表的负载因子大于等于 5 ；<br>如何扩容：</p>
<ul>
<li>为 ht[1] 分配空间， 让字典同时持有 ht[0] 和 ht[1] 两个哈希表。</li>
<li>在字典中维持一个索引计数器变量 rehashidx ， 并将它的值设置为 0 ， 表示 rehash 工作正式开始。</li>
<li>在 rehash 进行期间， 每次对字典执行添加、删除、查找或者更新操作时， 程序除了执行指定的操作以外， 还会顺带将 ht[0] 哈希表在 rehashidx 索引上的所有键值对 rehash 到 ht[1] ， 当 rehash 工作完成之后， 程序将 rehashidx 属性的值增1。</li>
<li>随着字典操作的不断执行， 最终在某个时间点上， ht[0] 的所有键值对都会被 rehash 至 ht[1] ， 这时程序将 rehashidx 属性的值设为 -1 ， 表示 rehash 操作已完成。<br>rehash的过程中有数据变化怎么办？<br>关于字典的操作无非就是四个，增删改查。<br>增加：直接将key-value对增加到h[1]中，即新的哈希表中<br>删除：先删除h[0]，再删除h[1]，保证都删掉<br>修改：直接修改h[1]<br>查找：先在h[0]中查找，查询不到再到h[1]中</li>
</ul>
</p></div></div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2023-03-20</span><a class="tag" href="/categories/Redis/" title="Redis">Redis </a><i class="fa fa-tag"></i><a class="tag" href="/tags/面试/" title="面试">面试 </a><i class="fa fa-tag"></i><a class="tag" href="/tags/Redis/" title="Redis">Redis </a><span class="leancloud_visitors"></span><span>About 2794 words, 9 min 18 sec  read</span></div></div></div></div><div class="post animated fadeInDown"><div class="post-title"><h3><a href="/2023/03/15/handelerr/">go-面试-异常处理</a></h3></div><div class="post-content"><div class="card"><p><p>&emsp;&emsp;&emsp;这是一篇关于golang面试题的文章，主要是记录本人在面试过程中常见的一些题目以及自己认为可能会考察的面试题。当然里面的内容也是用我自己的话术来总结的，可能存在不严谨的地方，还望指出！！！</p>
<h2 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h2></p></div></div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2023-03-15</span><a class="tag" href="/categories/Golang/" title="Golang">Golang </a><i class="fa fa-tag"></i><a class="tag" href="/tags/Golang/" title="Golang">Golang </a><i class="fa fa-tag"></i><a class="tag" href="/tags/面试/" title="面试">面试 </a><span class="leancloud_visitors"></span><span>About 96 words, 19 sec  read</span></div></div></div></div><div class="post animated fadeInDown"><div class="post-title"><h3><a href="/2023/03/14/concurrent/">go-面试-并发控制</a></h3></div><div class="post-content"><div class="card"><p></p></div></div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2023-03-14</span><a class="tag" href="/categories/Golang/" title="Golang">Golang </a><i class="fa fa-tag"></i><a class="tag" href="/tags/Golang/" title="Golang">Golang </a><i class="fa fa-tag"></i><a class="tag" href="/tags/面试/" title="面试">面试 </a><span class="leancloud_visitors"></span><span>About 0 words, 0 sec  read</span></div></div></div></div><div class="pagination"><ul class="clearfix"><li class="pre pagbuttons"><a class="btn" role="navigation" href="/">Previous</a></li><li class="next pagbuttons"><a class="btn" role="navigation" href="/page/3/">Next</a></li></ul></div></div></div></div><script src="/js/darkLightToggle.js"></script><script src="/js/jquery-migrate-1.2.1.min.js"></script><script src="/js/jquery.appear.js"></script><script src="/js/add-bookmark.js"></script><script>(function(window){var INSIGHT_CONFIG={TRANSLATION:{POSTS:"Posts",PAGES:"Pages",CATEGORIES:"Categories",TAGS:"Tags",UNTITLED:"(Untitled)",},CONTENT_URL:"/content.json",};window.INSIGHT_CONFIG=INSIGHT_CONFIG})(window);</script><script src="/js/insight.js" defer></script><div class="searchbox ins-search"><div class="searchbox-container ins-search-container"><div class="searchbox-input-wrapper"><input class="searchbox-input ins-search-input" type="text" placeholder="Search..."><span class="searchbox-close"><a class="fa fa-times-circle" onclick="closeWindow();"></a></span></div><div class="searchbox-result-wrapper ins-section-wrapper"><div class="ins-section-container"><p>Seraching...</p></div></div></div></div></body></html>